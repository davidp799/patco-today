<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/MainActivity.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday&#10;&#10;import android.content.SharedPreferences&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.SystemBarStyle&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.preference.PreferenceManager&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.ui.components.BottomNavigationBar&#10;import com.davidp799.patcotoday.ui.components.SideNavigationRail&#10;import com.davidp799.patcotoday.ui.components.SpecialScheduleBottomSheet&#10;import com.davidp799.patcotoday.ui.components.TopNavigationBar&#10;import com.davidp799.patcotoday.ui.navigation.Navigation&#10;import com.davidp799.patcotoday.ui.screens.SchedulesScreenViewModel&#10;import com.davidp799.patcotoday.ui.theme.PatcoTodayTheme&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.utils.VersionCodeStore&#10;import com.davidp799.patcotoday.ui.whatsnew.WhatsNewScreen&#10;import com.davidp799.patcotoday.ui.welcome.WelcomeScreen&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;import com.google.android.play.core.review.ReviewException&#10;import com.google.android.play.core.review.ReviewManagerFactory&#10;import com.google.android.play.core.review.model.ReviewErrorCode&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.launch&#10;import com.davidp799.patcotoday.utils.PreferenceMigration&#10;import androidx.core.content.edit&#10;&#10;class MainActivity : ComponentActivity(), SharedPreferences.OnSharedPreferenceChangeListener {&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var isFirstRunComplete = mutableStateOf(false)&#10;    private var firstRunLoadingMessage = mutableStateOf(&quot;Loading schedules...&quot;)&#10;    // Add a CompletableDeferred to track API call completion&#10;    private val apiCallCompletion = CompletableDeferred&lt;Boolean&gt;()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Install the splash screen&#10;        val splashScreen = installSplashScreen()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Migrate preferences from version 1.x.x to 2.0 before any other preference operations&#10;        PreferenceMigration.migratePreferencesIfNeeded(this)&#10;&#10;        // Keep splash screen visible until app is ready (but not during first launch loading screen)&#10;        splashScreen.setKeepOnScreenCondition {&#10;            !isFirstRunComplete.value&#10;        }&#10;&#10;        // Get theme preferences to configure system bars&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val themePreference = prefs.getString(&quot;device_theme&quot;, &quot;3&quot;)?.toInt() ?: 3&#10;        val isSystemInDarkTheme = resources.configuration.uiMode and&#10;            Configuration.UI_MODE_NIGHT_MASK ==&#10;            Configuration.UI_MODE_NIGHT_YES&#10;&#10;        // Determine if we should use dark theme&#10;        val useDarkTheme = when (themePreference) {&#10;            1 -&gt; false // Light theme&#10;            2 -&gt; true  // Dark theme&#10;            3 -&gt; isSystemInDarkTheme // Follow system&#10;            else -&gt; isSystemInDarkTheme&#10;        }&#10;&#10;        // Configure edge-to-edge with proper system bar styles&#10;        enableEdgeToEdge(&#10;            statusBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.TRANSPARENT)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.TRANSPARENT, android.graphics.Color.TRANSPARENT)&#10;            },&#10;            navigationBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.TRANSPARENT)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.TRANSPARENT, android.graphics.Color.TRANSPARENT)&#10;            }&#10;        )&#10;&#10;        // Initialize repository&#10;        scheduleRepository = ScheduleRepository(this)&#10;&#10;        // Register preference change listener&#10;        prefs.registerOnSharedPreferenceChangeListener(this)&#10;&#10;        // Handle first run logic completely before showing main UI&#10;        lifecycleScope.launch {&#10;            handleFirstRunAndDataLoading()&#10;        }&#10;&#10;        setContent {&#10;            PatcoTodayTheme {&#10;                var showWhatsNew by remember { mutableStateOf(false) }&#10;                var showWelcome by remember { mutableStateOf(false) }&#10;                val context = this&#10;&#10;                LaunchedEffect(Unit) {&#10;                    val currentVersionCode = BuildConfig.VERSION_CODE&#10;                    val savedVersionCode = VersionCodeStore.getVersionCode(context)&#10;&#10;                    // Check if this is a first-time user (no version saved)&#10;                    if (savedVersionCode == -1) {&#10;                        showWelcome = true&#10;                        // Start API call immediately for first-time users&#10;                        lifecycleScope.launch {&#10;                            scheduleRepository.fetchAndUpdateSchedules()&#10;                                .onSuccess { apiResponse -&gt;&#10;                                    // Check if regular schedules were updated&#10;                                    val regularSchedules = apiResponse.regularSchedules&#10;                                    if (regularSchedules == null) {&#10;                                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                                    }&#10;                                }&#10;                                .onFailure { error -&gt;&#10;                                    Log.e(&quot;[WelcomeScreen]&quot;, &quot;API call failed: ${error.message}&quot;)&#10;                                    // Show appropriate error message based on error type&#10;                                    val errorMessage = when (error) {&#10;                                        is UnknownHostException -&gt; {&#10;                                            &quot;No internet connection. Using offline schedules.&quot;&#10;                                        }&#10;                                        is SocketTimeoutException -&gt; {&#10;                                            &quot;Request timed out. Using offline schedules.&quot;&#10;                                        }&#10;                                        else -&gt; {&#10;                                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                                &quot;Server error. Using offline schedules.&quot;&#10;                                            } else {&#10;                                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                                } else {&#10;                                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;                                }&#10;                        }&#10;                    } else if (currentVersionCode &gt; savedVersionCode) {&#10;                        // Existing user with an update&#10;                        showWhatsNew = true&#10;                    }&#10;                }&#10;&#10;                when {&#10;                    showWelcome -&gt; {&#10;                        WelcomeScreen(onGetStarted = {&#10;                            showWelcome = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    showWhatsNew -&gt; {&#10;                        WhatsNewScreen(onDismiss = {&#10;                            showWhatsNew = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    else -&gt; {&#10;                        if (isFirstRunComplete.value) {&#10;                            MainScreen()&#10;                        } else {&#10;                            FirstRunLoadingScreen(loadingMessage = firstRunLoadingMessage.value)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleFirstRunAndDataLoading() {&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val isFirstRun = !prefs.getBoolean(&quot;first_run_completed&quot;, false)&#10;&#10;        if (isFirstRun) {&#10;            // Show appropriate loading message for first run&#10;            firstRunLoadingMessage.value = &quot;Downloading latest schedules...&quot;&#10;&#10;            // Perform first run API call and wait for completion&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Mark first run as completed&#10;                    prefs.edit { putBoolean(&quot;first_run_completed&quot;, true) }&#10;&#10;                    // Check if regular schedules were updated&#10;                    val regularSchedules = apiResponse.regularSchedules&#10;                    if (regularSchedules == null) {&#10;                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                    }&#10;&#10;                    // Request app review after successful data load&#10;                    requestReview()&#10;&#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[checkIfFirstRun]&quot;, &quot;First run API call failed: ${error.message}&quot;)&#10;&#10;                    // Mark first run as completed anyway so UI can proceed with fallback data&#10;                    prefs.edit {&#10;                        putBoolean(&quot;first_run_completed&quot;, true)&#10;                            .putBoolean(&quot;using_fallback_data&quot;, true)&#10;                    }&#10;&#10;                    // Show appropriate error message based on error type&#10;                    val errorMessage = when (error) {&#10;                        is UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Using offline schedules.&quot;&#10;                        }&#10;                        is SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Using offline schedules.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                &quot;Server error. Using offline schedules.&quot;&#10;                            } else {&#10;                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                } else {&#10;                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;&#10;                    // Request app review even on API failure to track visits&#10;                    requestReview()&#10;&#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        } else {&#10;            // Not first run, but still wait for API call to complete before showing UI&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Check if regular schedules were updated&#10;                    apiResponse.regularSchedules&#10;                    requestReview()&#10;&#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[MainActivity]&quot;, &quot;Background API call failed: ${error.message}&quot;)&#10;                    // Don't show error messages for background updates unless critical&#10;                    requestReview()&#10;&#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        }&#10;&#10;        // Mark first run as complete so UI can be shown&#10;        isFirstRunComplete.value = true&#10;    }&#10;&#10;    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {&#10;        when (key) {&#10;            &quot;device_theme&quot;, &quot;dynamic_colors&quot; -&gt; {&#10;                // Recreate activity to apply theme changes&#10;                recreate()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        PreferenceManager.getDefaultSharedPreferences(this)&#10;            .unregisterOnSharedPreferenceChangeListener(this)&#10;    }&#10;&#10;    private fun showToast(message: String) {&#10;        runOnUiThread {&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Request Google Play Store app review&#10;    private fun requestReview() {&#10;        val prefVisitNumber = &quot;visit_number&quot;&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val visitNumber = prefs.getInt(prefVisitNumber, 0)&#10;        val sharedPreferencesEditor = prefs.edit()&#10;&#10;        if (visitNumber % 10 == 0) {&#10;            val reviewManager = ReviewManagerFactory.create(this)&#10;            val requestReviewFlow = reviewManager.requestReviewFlow()&#10;            requestReviewFlow.addOnCompleteListener {&#10;                if (it.isSuccessful) {&#10;                    val reviewInfo = it.result&#10;                    val reviewFlow = reviewManager.launchReviewFlow(this, reviewInfo)&#10;                    reviewFlow.addOnCompleteListener {&#10;                        sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                    }&#10;                } else {&#10;                    @ReviewErrorCode val reviewErrorCode = (it.exception as? ReviewException)?.errorCode&#10;                    Log.e(&#10;                        &quot;[requestReview]&quot;,&#10;                        &quot;reviewErrorCode = $reviewErrorCode&quot;&#10;                    )&#10;                    // Still increment visit number even if review request failed&#10;                    sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                }&#10;            }&#10;        } else {&#10;            sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FirstRunLoadingScreen(loadingMessage: String) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            CircularProgressIndicator(&#10;                modifier = Modifier.size(48.dp),&#10;                strokeWidth = 4.dp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = loadingMessage,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen() {&#10;    val navController = rememberNavController()&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    // Create ViewModel instance once and reuse it&#10;    val schedulesViewModel: SchedulesScreenViewModel = viewModel()&#10;    val schedulesUiState by schedulesViewModel.uiState.collectAsState()&#10;&#10;    // Set up toast callback for the ViewModel&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    LaunchedEffect(Unit) {&#10;        schedulesViewModel.setShowToastCallback { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Animate blur effect when refreshing schedules&#10;    val blurRadius by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 8f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_blur_effect&quot;&#10;    )&#10;&#10;    // Animate overlay alpha when refreshing schedules&#10;    val overlayAlpha by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 0.3f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_overlay_fade&quot;&#10;    )&#10;&#10;    // Detect screen orientation&#10;    val configuration = LocalConfiguration.current&#10;    val isPortrait = configuration.orientation == Configuration.ORIENTATION_PORTRAIT&#10;&#10;    // Bottom sheet state - for landscape mode only&#10;    val landscapeBottomSheetState = rememberStandardBottomSheetState(&#10;        initialValue = if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet)&#10;            SheetValue.PartiallyExpanded else SheetValue.Hidden,&#10;        skipHiddenState = false&#10;    )&#10;&#10;    // Handle bottom sheet state changes for landscape&#10;    LaunchedEffect(isPortrait, currentRoute, schedulesUiState.showSpecialScheduleSheet) {&#10;        if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet &amp;&amp; !schedulesUiState.hasUserDismissedSheet) {&#10;            landscapeBottomSheetState.partialExpand()&#10;        } else {&#10;            landscapeBottomSheetState.hide()&#10;        }&#10;    }&#10;&#10;    // Handle when user manually dismisses sheet in landscape&#10;    LaunchedEffect(landscapeBottomSheetState.targetValue) {&#10;        if (landscapeBottomSheetState.targetValue == SheetValue.Hidden &amp;&amp;&#10;            !isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet) {&#10;            schedulesViewModel.dismissSpecialScheduleSheet()&#10;        }&#10;    }&#10;&#10;    if (isPortrait) {&#10;        // Portrait mode: Bottom sheet contained within main content area&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            Scaffold(&#10;                topBar = {&#10;                    TopNavigationBar(&#10;                        navController = navController,&#10;                        onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                            { schedulesViewModel.refreshSchedules() }&#10;                        } else null,&#10;                        isRefreshing = schedulesUiState.isRefreshing&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    BottomNavigationBar(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;                },&#10;                modifier = Modifier.blur(radius = blurRadius.dp)&#10;            ) { innerPadding -&gt;&#10;                // Portrait mode: Use SchedulesScreen with its own bottom sheet for schedules screen&#10;                Navigation(&#10;                    navController = navController,&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                    useInternalBottomSheet = true // Flag to tell SchedulesScreen to use its own bottom sheet&#10;                )&#10;            }&#10;&#10;            // Blur overlay when refreshing schedules&#10;            if (overlayAlpha &gt; 0f) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Color.Black.copy(alpha = overlayAlpha)&#10;                        )&#10;                )&#10;            }&#10;&#10;            // Loading indicator on top of blur&#10;            if (schedulesUiState.isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(48.dp),&#10;                        strokeWidth = 4.dp,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    } else {&#10;        // Landscape mode: Bottom sheet at top level spans full screen&#10;        BottomSheetScaffold(&#10;            scaffoldState = rememberBottomSheetScaffoldState(bottomSheetState = landscapeBottomSheetState),&#10;            sheetContent = {&#10;                if (currentRoute == &quot;schedules&quot;) {&#10;                    SpecialScheduleBottomSheet(&#10;                        specialScheduleState = schedulesUiState.specialScheduleState,&#10;                        onViewSchedule = { schedulesViewModel.openSpecialSchedulePdf() }&#10;                    )&#10;                } else {&#10;                    // Empty content when not on schedules screen&#10;                    Spacer(modifier = Modifier.height(1.dp))&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .blur(radius = blurRadius.dp)&#10;                ) {&#10;                    // Side navigation rail&#10;                    SideNavigationRail(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;&#10;                    // Main content area&#10;                    Scaffold(&#10;                        topBar = {&#10;                            TopNavigationBar(&#10;                                navController = navController,&#10;                                onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                                    { schedulesViewModel.refreshSchedules() }&#10;                                } else null,&#10;                                isRefreshing = schedulesUiState.isRefreshing&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) { innerPadding -&gt;&#10;                        Navigation(&#10;                            navController = navController,&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                            useInternalBottomSheet = false // Flag to tell SchedulesScreen NOT to use its own bottom sheet&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Blur overlay when refreshing schedules&#10;                if (overlayAlpha &gt; 0f) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Color.Black.copy(alpha = overlayAlpha)&#10;                            )&#10;                    )&#10;                }&#10;&#10;                // Loading indicator on top of blur&#10;                if (schedulesUiState.isRefreshing) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(48.dp),&#10;                            strokeWidth = 4.dp,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    PatcoTodayTheme {&#10;        MainScreen()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.davidp799.patcotoday&#10;&#10;import android.content.SharedPreferences&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.SystemBarStyle&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.preference.PreferenceManager&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.ui.components.BottomNavigationBar&#10;import com.davidp799.patcotoday.ui.components.SideNavigationRail&#10;import com.davidp799.patcotoday.ui.components.SpecialScheduleBottomSheet&#10;import com.davidp799.patcotoday.ui.components.TopNavigationBar&#10;import com.davidp799.patcotoday.ui.navigation.Navigation&#10;import com.davidp799.patcotoday.ui.screens.SchedulesScreenViewModel&#10;import com.davidp799.patcotoday.ui.theme.PatcoTodayTheme&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.utils.VersionCodeStore&#10;import com.davidp799.patcotoday.ui.whatsnew.WhatsNewScreen&#10;import com.davidp799.patcotoday.ui.welcome.WelcomeScreen&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;import com.google.android.play.core.review.ReviewException&#10;import com.google.android.play.core.review.ReviewManagerFactory&#10;import com.google.android.play.core.review.model.ReviewErrorCode&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.launch&#10;import com.davidp799.patcotoday.utils.PreferenceMigration&#10;import androidx.core.content.edit&#10;&#10;class MainActivity : ComponentActivity(), SharedPreferences.OnSharedPreferenceChangeListener {&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var isFirstRunComplete = mutableStateOf(false)&#10;    private var firstRunLoadingMessage = mutableStateOf(&quot;Loading schedules...&quot;)&#10;    // Add a CompletableDeferred to track API call completion&#10;    private val apiCallCompletion = CompletableDeferred&lt;Boolean&gt;()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Install the splash screen&#10;        val splashScreen = installSplashScreen()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Migrate preferences from version 1.x.x to 2.0 before any other preference operations&#10;        PreferenceMigration.migratePreferencesIfNeeded(this)&#10;&#10;        // Keep splash screen visible until app is ready (but not during first launch loading screen)&#10;        splashScreen.setKeepOnScreenCondition {&#10;            !isFirstRunComplete.value&#10;        }&#10;&#10;        // Get theme preferences to configure system bars&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val themePreference = prefs.getString(&quot;device_theme&quot;, &quot;3&quot;)?.toInt() ?: 3&#10;        val isSystemInDarkTheme = resources.configuration.uiMode and&#10;            Configuration.UI_MODE_NIGHT_MASK ==&#10;            Configuration.UI_MODE_NIGHT_YES&#10;&#10;        // Determine if we should use dark theme&#10;        val useDarkTheme = when (themePreference) {&#10;            1 -&gt; false // Light theme&#10;            2 -&gt; true  // Dark theme&#10;            3 -&gt; isSystemInDarkTheme // Follow system&#10;            else -&gt; isSystemInDarkTheme&#10;        }&#10;&#10;        // Configure edge-to-edge with proper system bar styles&#10;        enableEdgeToEdge(&#10;            statusBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.TRANSPARENT)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.TRANSPARENT, android.graphics.Color.TRANSPARENT)&#10;            },&#10;            navigationBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.TRANSPARENT)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.TRANSPARENT, android.graphics.Color.TRANSPARENT)&#10;            }&#10;        )&#10;&#10;        // Initialize repository&#10;        scheduleRepository = ScheduleRepository(this)&#10;&#10;        // Clean up old special schedule files (keep only today's)&#10;        val today = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        scheduleRepository.fileManager.cleanupOldSpecialSchedules(today)&#10;&#10;        // Register preference change listener&#10;        prefs.registerOnSharedPreferenceChangeListener(this)&#10;&#10;        // Handle first run logic completely before showing main UI&#10;        lifecycleScope.launch {&#10;            handleFirstRunAndDataLoading()&#10;        }&#10;&#10;        setContent {&#10;            PatcoTodayTheme {&#10;                var showWhatsNew by remember { mutableStateOf(false) }&#10;                var showWelcome by remember { mutableStateOf(false) }&#10;                val context = this&#10;&#10;                LaunchedEffect(Unit) {&#10;                    val currentVersionCode = BuildConfig.VERSION_CODE&#10;                    val savedVersionCode = VersionCodeStore.getVersionCode(context)&#10;&#10;                    // Check if this is a first-time user (no version saved)&#10;                    if (savedVersionCode == -1) {&#10;                        showWelcome = true&#10;                        // Start API call immediately for first-time users&#10;                        lifecycleScope.launch {&#10;                            scheduleRepository.fetchAndUpdateSchedules()&#10;                                .onSuccess { apiResponse -&gt;&#10;                                    // Check if regular schedules were updated&#10;                                    val regularSchedules = apiResponse.regularSchedules&#10;                                    if (regularSchedules == null) {&#10;                                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                                    }&#10;                                }&#10;                                .onFailure { error -&gt;&#10;                                    Log.e(&quot;[WelcomeScreen]&quot;, &quot;API call failed: ${error.message}&quot;)&#10;                                    // Show appropriate error message based on error type&#10;                                    val errorMessage = when (error) {&#10;                                        is UnknownHostException -&gt; {&#10;                                            &quot;No internet connection. Using offline schedules.&quot;&#10;                                        }&#10;                                        is SocketTimeoutException -&gt; {&#10;                                            &quot;Request timed out. Using offline schedules.&quot;&#10;                                        }&#10;                                        else -&gt; {&#10;                                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                                &quot;Server error. Using offline schedules.&quot;&#10;                                            } else {&#10;                                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                                } else {&#10;                                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;                                }&#10;                        }&#10;                    } else if (currentVersionCode &gt; savedVersionCode) {&#10;                        // Existing user with an update&#10;                        showWhatsNew = true&#10;                    }&#10;                }&#10;&#10;                when {&#10;                    showWelcome -&gt; {&#10;                        WelcomeScreen(onGetStarted = {&#10;                            showWelcome = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    showWhatsNew -&gt; {&#10;                        WhatsNewScreen(onDismiss = {&#10;                            showWhatsNew = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    else -&gt; {&#10;                        if (isFirstRunComplete.value) {&#10;                            MainScreen()&#10;                        } else {&#10;                            FirstRunLoadingScreen(loadingMessage = firstRunLoadingMessage.value)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleFirstRunAndDataLoading() {&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val isFirstRun = !prefs.getBoolean(&quot;first_run_completed&quot;, false)&#10;&#10;        if (isFirstRun) {&#10;            // Show appropriate loading message for first run&#10;            firstRunLoadingMessage.value = &quot;Downloading latest schedules...&quot;&#10;&#10;            // Perform first run API call and wait for completion&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Mark first run as completed&#10;                    prefs.edit { putBoolean(&quot;first_run_completed&quot;, true) }&#10;&#10;                    // Check if regular schedules were updated&#10;                    val regularSchedules = apiResponse.regularSchedules&#10;                    if (regularSchedules == null) {&#10;                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                    }&#10;&#10;                    // Request app review after successful data load&#10;                    requestReview()&#10;&#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[checkIfFirstRun]&quot;, &quot;First run API call failed: ${error.message}&quot;)&#10;&#10;                    // Mark first run as completed anyway so UI can proceed with fallback data&#10;                    prefs.edit {&#10;                        putBoolean(&quot;first_run_completed&quot;, true)&#10;                            .putBoolean(&quot;using_fallback_data&quot;, true)&#10;                    }&#10;&#10;                    // Show appropriate error message based on error type&#10;                    val errorMessage = when (error) {&#10;                        is UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Using offline schedules.&quot;&#10;                        }&#10;                        is SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Using offline schedules.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                &quot;Server error. Using offline schedules.&quot;&#10;                            } else {&#10;                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                } else {&#10;                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;&#10;                    // Request app review even on API failure to track visits&#10;                    requestReview()&#10;&#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        } else {&#10;            // Not first run, but still wait for API call to complete before showing UI&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Check if regular schedules were updated&#10;                    apiResponse.regularSchedules&#10;                    requestReview()&#10;&#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[MainActivity]&quot;, &quot;Background API call failed: ${error.message}&quot;)&#10;                    // Don't show error messages for background updates unless critical&#10;                    requestReview()&#10;&#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        }&#10;&#10;        // Mark first run as complete so UI can be shown&#10;        isFirstRunComplete.value = true&#10;    }&#10;&#10;    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {&#10;        when (key) {&#10;            &quot;device_theme&quot;, &quot;dynamic_colors&quot; -&gt; {&#10;                // Recreate activity to apply theme changes&#10;                recreate()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        PreferenceManager.getDefaultSharedPreferences(this)&#10;            .unregisterOnSharedPreferenceChangeListener(this)&#10;    }&#10;&#10;    private fun showToast(message: String) {&#10;        runOnUiThread {&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Request Google Play Store app review&#10;    private fun requestReview() {&#10;        val prefVisitNumber = &quot;visit_number&quot;&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val visitNumber = prefs.getInt(prefVisitNumber, 0)&#10;        val sharedPreferencesEditor = prefs.edit()&#10;&#10;        if (visitNumber % 10 == 0) {&#10;            val reviewManager = ReviewManagerFactory.create(this)&#10;            val requestReviewFlow = reviewManager.requestReviewFlow()&#10;            requestReviewFlow.addOnCompleteListener {&#10;                if (it.isSuccessful) {&#10;                    val reviewInfo = it.result&#10;                    val reviewFlow = reviewManager.launchReviewFlow(this, reviewInfo)&#10;                    reviewFlow.addOnCompleteListener {&#10;                        sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                    }&#10;                } else {&#10;                    @ReviewErrorCode val reviewErrorCode = (it.exception as? ReviewException)?.errorCode&#10;                    Log.e(&#10;                        &quot;[requestReview]&quot;,&#10;                        &quot;reviewErrorCode = $reviewErrorCode&quot;&#10;                    )&#10;                    // Still increment visit number even if review request failed&#10;                    sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                }&#10;            }&#10;        } else {&#10;            sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FirstRunLoadingScreen(loadingMessage: String) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            CircularProgressIndicator(&#10;                modifier = Modifier.size(48.dp),&#10;                strokeWidth = 4.dp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = loadingMessage,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen() {&#10;    val navController = rememberNavController()&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    // Create ViewModel instance once and reuse it&#10;    val schedulesViewModel: SchedulesScreenViewModel = viewModel()&#10;    val schedulesUiState by schedulesViewModel.uiState.collectAsState()&#10;&#10;    // Set up toast callback for the ViewModel&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    LaunchedEffect(Unit) {&#10;        schedulesViewModel.setShowToastCallback { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Animate blur effect when refreshing schedules&#10;    val blurRadius by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 8f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_blur_effect&quot;&#10;    )&#10;&#10;    // Animate overlay alpha when refreshing schedules&#10;    val overlayAlpha by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 0.3f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_overlay_fade&quot;&#10;    )&#10;&#10;    // Detect screen orientation&#10;    val configuration = LocalConfiguration.current&#10;    val isPortrait = configuration.orientation == Configuration.ORIENTATION_PORTRAIT&#10;&#10;    // Bottom sheet state - for landscape mode only&#10;    val landscapeBottomSheetState = rememberStandardBottomSheetState(&#10;        initialValue = if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet)&#10;            SheetValue.PartiallyExpanded else SheetValue.Hidden,&#10;        skipHiddenState = false&#10;    )&#10;&#10;    // Handle bottom sheet state changes for landscape&#10;    LaunchedEffect(isPortrait, currentRoute, schedulesUiState.showSpecialScheduleSheet) {&#10;        if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet &amp;&amp; !schedulesUiState.hasUserDismissedSheet) {&#10;            landscapeBottomSheetState.partialExpand()&#10;        } else {&#10;            landscapeBottomSheetState.hide()&#10;        }&#10;    }&#10;&#10;    // Handle when user manually dismisses sheet in landscape&#10;    LaunchedEffect(landscapeBottomSheetState.targetValue) {&#10;        if (landscapeBottomSheetState.targetValue == SheetValue.Hidden &amp;&amp;&#10;            !isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet) {&#10;            schedulesViewModel.dismissSpecialScheduleSheet()&#10;        }&#10;    }&#10;&#10;    if (isPortrait) {&#10;        // Portrait mode: Bottom sheet contained within main content area&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            Scaffold(&#10;                topBar = {&#10;                    TopNavigationBar(&#10;                        navController = navController,&#10;                        onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                            { schedulesViewModel.refreshSchedules() }&#10;                        } else null,&#10;                        isRefreshing = schedulesUiState.isRefreshing&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    BottomNavigationBar(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;                },&#10;                modifier = Modifier.blur(radius = blurRadius.dp)&#10;            ) { innerPadding -&gt;&#10;                // Portrait mode: Use SchedulesScreen with its own bottom sheet for schedules screen&#10;                Navigation(&#10;                    navController = navController,&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                    useInternalBottomSheet = true // Flag to tell SchedulesScreen to use its own bottom sheet&#10;                )&#10;            }&#10;&#10;            // Blur overlay when refreshing schedules&#10;            if (overlayAlpha &gt; 0f) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Color.Black.copy(alpha = overlayAlpha)&#10;                        )&#10;                )&#10;            }&#10;&#10;            // Loading indicator on top of blur&#10;            if (schedulesUiState.isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(48.dp),&#10;                        strokeWidth = 4.dp,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    } else {&#10;        // Landscape mode: Bottom sheet at top level spans full screen&#10;        BottomSheetScaffold(&#10;            scaffoldState = rememberBottomSheetScaffoldState(bottomSheetState = landscapeBottomSheetState),&#10;            sheetContent = {&#10;                if (currentRoute == &quot;schedules&quot;) {&#10;                    SpecialScheduleBottomSheet(&#10;                        specialScheduleState = schedulesUiState.specialScheduleState,&#10;                        onViewSchedule = { schedulesViewModel.openSpecialSchedulePdf() }&#10;                    )&#10;                } else {&#10;                    // Empty content when not on schedules screen&#10;                    Spacer(modifier = Modifier.height(1.dp))&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .blur(radius = blurRadius.dp)&#10;                ) {&#10;                    // Side navigation rail&#10;                    SideNavigationRail(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;&#10;                    // Main content area&#10;                    Scaffold(&#10;                        topBar = {&#10;                            TopNavigationBar(&#10;                                navController = navController,&#10;                                onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                                    { schedulesViewModel.refreshSchedules() }&#10;                                } else null,&#10;                                isRefreshing = schedulesUiState.isRefreshing&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) { innerPadding -&gt;&#10;                        Navigation(&#10;                            navController = navController,&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                            useInternalBottomSheet = false // Flag to tell SchedulesScreen NOT to use its own bottom sheet&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Blur overlay when refreshing schedules&#10;                if (overlayAlpha &gt; 0f) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Color.Black.copy(alpha = overlayAlpha)&#10;                            )&#10;                    )&#10;                }&#10;&#10;                // Loading indicator on top of blur&#10;                if (schedulesUiState.isRefreshing) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(48.dp),&#10;                            strokeWidth = 4.dp,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    PatcoTodayTheme {&#10;        MainScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/data/local/FileManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/data/local/FileManager.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday.data.local&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class FileManager(private val context: Context) {&#10;&#10;    private val client = OkHttpClient()&#10;&#10;    private fun getSchedulesDirectory(): File {&#10;        val schedulesDir = File(context.filesDir, &quot;schedules&quot;)&#10;        if (!schedulesDir.exists()) {&#10;            schedulesDir.mkdirs()&#10;        }&#10;        return schedulesDir&#10;    }&#10;&#10;    private fun getRegularSchedulesDirectory(): File {&#10;        val regularDir = File(getSchedulesDirectory(), &quot;regular&quot;)&#10;        if (!regularDir.exists()) {&#10;            regularDir.mkdirs()&#10;        }&#10;        return regularDir&#10;    }&#10;&#10;    private fun getSpecialSchedulesDirectory(date: String): File {&#10;        val specialDir = File(getSchedulesDirectory(), &quot;special&quot;)&#10;        if (!specialDir.exists()) {&#10;            specialDir.mkdirs()&#10;        }&#10;        val dateDir = File(specialDir, date)&#10;        if (!dateDir.exists()) {&#10;            dateDir.mkdirs()&#10;        }&#10;        return dateDir&#10;    }&#10;&#10;    suspend fun downloadAndSaveFile(url: String, fileName: String, isSpecial: Boolean = false, date: String? = null): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Check if network operations are allowed based on mobile data settings&#10;                if (!NetworkUtils.shouldAllowNetworkOperation(context)) {&#10;                    withContext(Dispatchers.Main) {&#10;                        NetworkUtils.showMobileDataBlockedToast(context)&#10;                    }&#10;                    return@withContext false&#10;                }&#10;&#10;                val request = Request.Builder().url(url).build()&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val directory = if (isSpecial &amp;&amp; date != null) {&#10;                        getSpecialSchedulesDirectory(date)&#10;                    } else {&#10;                        getRegularSchedulesDirectory()&#10;                    }&#10;&#10;                    val file = File(directory, fileName)&#10;                    val inputStream = response.body?.byteStream()&#10;                    val outputStream = FileOutputStream(file)&#10;&#10;                    inputStream?.copyTo(outputStream)&#10;                    inputStream?.close()&#10;                    outputStream.close()&#10;&#10;                    true&#10;                } else {&#10;                    Log.e(&quot;[downloadAndSaveFile]&quot;, &quot;File download failed - Code: ${response.code}, URL: $url&quot;)&#10;                    false&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[downloadAndSaveFile]&quot;, &quot;File download exception for $fileName: ${e.message}&quot;, e)&#10;                e.printStackTrace()&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun downloadAndSavePdf(url: String, fileName: String, date: String): Boolean {&#10;        return downloadAndSaveFile(url, fileName, isSpecial = true, date = date)&#10;    }&#10;&#10;    fun getOldestLastModified(): String {&#10;        val files = listOf(&#10;            &quot;weekdays_east.csv&quot;,&#10;            &quot;weekdays_west.csv&quot;,&#10;            &quot;saturdays_east.csv&quot;,&#10;            &quot;saturdays_west.csv&quot;,&#10;            &quot;sundays_east.csv&quot;,&#10;            &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        var oldestTime = Long.MAX_VALUE&#10;        files.forEach { fileName -&gt;&#10;            val file = File(getRegularSchedulesDirectory(), fileName)&#10;            if (file.exists()) {&#10;                oldestTime = minOf(oldestTime, file.lastModified())&#10;            } else {&#10;                // If any file doesn't exist, return a very old date&#10;                return &quot;2020-01-01T00:00:00Z&quot;&#10;            }&#10;        }&#10;&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, Locale.getDefault())&#10;        return if (oldestTime == Long.MAX_VALUE) {&#10;            &quot;2020-01-01T00:00:00Z&quot;&#10;        } else {&#10;            dateFormat.format(Date(oldestTime))&#10;        }&#10;    }&#10;&#10;    fun getLastUpdateTimeFormatted(): String {&#10;        val files = listOf(&#10;            &quot;weekdays_east.csv&quot;,&#10;            &quot;weekdays_west.csv&quot;,&#10;            &quot;saturdays_east.csv&quot;,&#10;            &quot;saturdays_west.csv&quot;,&#10;            &quot;sundays_east.csv&quot;,&#10;            &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        var oldestTime = Long.MAX_VALUE&#10;        files.forEach { fileName -&gt;&#10;            val file = File(getRegularSchedulesDirectory(), fileName)&#10;            if (file.exists()) {&#10;                oldestTime = minOf(oldestTime, file.lastModified())&#10;            } else {&#10;                // If any file doesn't exist, return a message indicating no updates&#10;                return &quot;Never updated&quot;&#10;            }&#10;        }&#10;&#10;        return if (oldestTime == Long.MAX_VALUE) {&#10;            &quot;Never updated&quot;&#10;        } else {&#10;            val dateFormat = SimpleDateFormat(&quot;MMM dd, yyyy 'at' hh:mm a&quot;, Locale.getDefault())&#10;            &quot;Last updated: ${dateFormat.format(Date(oldestTime))}&quot;&#10;        }&#10;    }&#10;&#10;    fun getSpecialScheduleFile(date: String, fileName: String): File? {&#10;        val file = File(getSpecialSchedulesDirectory(date), fileName)&#10;        val exists = file.exists()&#10;        return if (exists) file else null&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.davidp799.patcotoday.data.local&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class FileManager(private val context: Context) {&#10;&#10;    private val client = OkHttpClient()&#10;&#10;    private fun getSchedulesDirectory(): File {&#10;        val schedulesDir = File(context.filesDir, &quot;schedules&quot;)&#10;        if (!schedulesDir.exists()) {&#10;            schedulesDir.mkdirs()&#10;        }&#10;        return schedulesDir&#10;    }&#10;&#10;    private fun getRegularSchedulesDirectory(): File {&#10;        val regularDir = File(getSchedulesDirectory(), &quot;regular&quot;)&#10;        if (!regularDir.exists()) {&#10;            regularDir.mkdirs()&#10;        }&#10;        return regularDir&#10;    }&#10;&#10;    private fun getSpecialSchedulesDirectory(date: String): File {&#10;        val specialDir = File(getSchedulesDirectory(), &quot;special&quot;)&#10;        if (!specialDir.exists()) {&#10;            specialDir.mkdirs()&#10;        }&#10;        val dateDir = File(specialDir, date)&#10;        if (!dateDir.exists()) {&#10;            dateDir.mkdirs()&#10;        }&#10;        return dateDir&#10;    }&#10;&#10;    suspend fun downloadAndSaveFile(url: String, fileName: String, isSpecial: Boolean = false, date: String? = null): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Check if network operations are allowed based on mobile data settings&#10;                if (!NetworkUtils.shouldAllowNetworkOperation(context)) {&#10;                    withContext(Dispatchers.Main) {&#10;                        NetworkUtils.showMobileDataBlockedToast(context)&#10;                    }&#10;                    return@withContext false&#10;                }&#10;&#10;                val request = Request.Builder().url(url).build()&#10;                val response = client.newCall(request).execute()&#10;&#10;                if (response.isSuccessful) {&#10;                    val directory = if (isSpecial &amp;&amp; date != null) {&#10;                        getSpecialSchedulesDirectory(date)&#10;                    } else {&#10;                        getRegularSchedulesDirectory()&#10;                    }&#10;&#10;                    val file = File(directory, fileName)&#10;                    val inputStream = response.body?.byteStream()&#10;                    val outputStream = FileOutputStream(file)&#10;&#10;                    inputStream?.copyTo(outputStream)&#10;                    inputStream?.close()&#10;                    outputStream.close()&#10;&#10;                    true&#10;                } else {&#10;                    Log.e(&quot;[downloadAndSaveFile]&quot;, &quot;File download failed - Code: ${response.code}, URL: $url&quot;)&#10;                    false&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[downloadAndSaveFile]&quot;, &quot;File download exception for $fileName: ${e.message}&quot;, e)&#10;                e.printStackTrace()&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun downloadAndSavePdf(url: String, fileName: String, date: String): Boolean {&#10;        return downloadAndSaveFile(url, fileName, isSpecial = true, date = date)&#10;    }&#10;&#10;    fun getOldestLastModified(): String {&#10;        val files = listOf(&#10;            &quot;weekdays_east.csv&quot;,&#10;            &quot;weekdays_west.csv&quot;,&#10;            &quot;saturdays_east.csv&quot;,&#10;            &quot;saturdays_west.csv&quot;,&#10;            &quot;sundays_east.csv&quot;,&#10;            &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        var oldestTime = Long.MAX_VALUE&#10;        files.forEach { fileName -&gt;&#10;            val file = File(getRegularSchedulesDirectory(), fileName)&#10;            if (file.exists()) {&#10;                oldestTime = minOf(oldestTime, file.lastModified())&#10;            } else {&#10;                // If any file doesn't exist, return a very old date&#10;                return &quot;2020-01-01T00:00:00Z&quot;&#10;            }&#10;        }&#10;&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, Locale.getDefault())&#10;        return if (oldestTime == Long.MAX_VALUE) {&#10;            &quot;2020-01-01T00:00:00Z&quot;&#10;        } else {&#10;            dateFormat.format(Date(oldestTime))&#10;        }&#10;    }&#10;&#10;    fun getLastUpdateTimeFormatted(): String {&#10;        val files = listOf(&#10;            &quot;weekdays_east.csv&quot;,&#10;            &quot;weekdays_west.csv&quot;,&#10;            &quot;saturdays_east.csv&quot;,&#10;            &quot;saturdays_west.csv&quot;,&#10;            &quot;sundays_east.csv&quot;,&#10;            &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        var oldestTime = Long.MAX_VALUE&#10;        files.forEach { fileName -&gt;&#10;            val file = File(getRegularSchedulesDirectory(), fileName)&#10;            if (file.exists()) {&#10;                oldestTime = minOf(oldestTime, file.lastModified())&#10;            } else {&#10;                // If any file doesn't exist, return a message indicating no updates&#10;                return &quot;Never updated&quot;&#10;            }&#10;        }&#10;&#10;        return if (oldestTime == Long.MAX_VALUE) {&#10;            &quot;Never updated&quot;&#10;        } else {&#10;            val dateFormat = SimpleDateFormat(&quot;MMM dd, yyyy 'at' hh:mm a&quot;, Locale.getDefault())&#10;            &quot;Last updated: ${dateFormat.format(Date(oldestTime))}&quot;&#10;        }&#10;    }&#10;&#10;    fun getSpecialScheduleFile(date: String, fileName: String): File? {&#10;        val file = File(getSpecialSchedulesDirectory(date), fileName)&#10;        val exists = file.exists()&#10;        return if (exists) file else null&#10;    }&#10;&#10;    fun cleanupOldSpecialSchedules(currentDate: String) {&#10;        val specialDir = File(getSchedulesDirectory(), &quot;special&quot;)&#10;        if (specialDir.exists() &amp;&amp; specialDir.isDirectory) {&#10;            specialDir.listFiles()?.forEach { subDir -&gt;&#10;                if (subDir.isDirectory &amp;&amp; subDir.name != currentDate) {&#10;                    try {&#10;                        subDir.deleteRecursively()&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;[cleanupOldSpecialSchedules]&quot;, &quot;Failed to delete ${subDir.absolutePath}: &quot;, e)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/data/repository/ScheduleRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/data/repository/ScheduleRepository.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday.data.repository&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.davidp799.patcotoday.data.api.ScheduleApiService&#10;import com.davidp799.patcotoday.data.local.FileManager&#10;import com.davidp799.patcotoday.data.local.CsvScheduleParser&#10;import com.davidp799.patcotoday.data.models.ApiResponse&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.BuildConfig&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ScheduleRepository(private val context: Context) {&#10;    private val fileManager = FileManager(context)&#10;    private val csvParser = CsvScheduleParser(context)&#10;    private val apiService: ScheduleApiService&#10;&#10;    // API key now read from BuildConfig, which gets it from local.properties&#10;    private val apiKey = BuildConfig.API_KEY&#10;    private val baseUrl = &quot;https://pyy0z7hm81.execute-api.us-east-1.amazonaws.com/&quot;&#10;&#10;    init {&#10;        val retrofit = Retrofit.Builder()&#10;            .baseUrl(baseUrl)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;&#10;        apiService = retrofit.create(ScheduleApiService::class.java)&#10;    }&#10;&#10;    suspend fun fetchAndUpdateSchedules(): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Check if network operations are allowed based on mobile data settings&#10;                if (!NetworkUtils.shouldAllowNetworkOperation(context)) {&#10;                    withContext(Dispatchers.Main) {&#10;                        NetworkUtils.showMobileDataBlockedToast(context)&#10;                    }&#10;                    return@withContext Result.failure(Exception(&quot;Network operation blocked due to mobile data restrictions&quot;))&#10;                }&#10;&#10;                val today = getCurrentDate()&#10;                val lastUpdated = fileManager.getOldestLastModified()&#10;                val response = apiService.getSchedules(&#10;                    scheduleDate = today,&#10;                    lastUpdated = lastUpdated,&#10;                    apiKey = apiKey&#10;                )&#10;&#10;                if (response.isSuccessful) {&#10;                    val apiResponse = response.body()!!&#10;&#10;                    // Download special schedules if available&#10;                    apiResponse.specialSchedules?.let { special -&gt;&#10;                        downloadSpecialSchedules(special.scheduleDate, special.eastboundUrl, special.westboundUrl, special.pdfUrl)&#10;                    }&#10;&#10;                    // Download regular schedules if updated&#10;                    apiResponse.regularSchedules?.let { regular -&gt;&#10;                        if (regular.updated &amp;&amp; regular.urls != null) {&#10;                            downloadRegularSchedules(regular.urls)&#10;                        }&#10;                    }&#10;&#10;                    Result.success(apiResponse)&#10;                } else {&#10;                    Log.e(&quot;[fetchAndUpdateSchedules]&quot;, &quot;API call failed with code: ${response.code()}&quot;)&#10;                    Result.failure(Exception(&quot;API call failed: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[fetchAndUpdateSchedules]&quot;, &quot;API call exception: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getScheduleForRoute(fromStation: String, toStation: String): List&lt;Arrival&gt; {&#10;        // First try to get from local files (downloaded from API)&#10;        val arrivals = csvParser.parseScheduleForRoute(fromStation, toStation)&#10;&#10;        if (arrivals.isNotEmpty()) {&#10;            return arrivals&#10;        }&#10;&#10;        // If no local data found, fall back to assets&#10;        val assetArrivals = csvParser.parseScheduleFromAssets(fromStation, toStation)&#10;        return assetArrivals&#10;    }&#10;&#10;    private suspend fun downloadSpecialSchedules(date: String, eastboundUrl: String, westboundUrl: String, pdfUrl: String) {&#10;        fileManager.downloadAndSaveFile(&#10;            url = eastboundUrl,&#10;            fileName = &quot;special_schedule_eastbound.csv&quot;,&#10;            isSpecial = true,&#10;            date = date&#10;        )&#10;&#10;        fileManager.downloadAndSaveFile(&#10;            url = westboundUrl,&#10;            fileName = &quot;special_schedule_westbound.csv&quot;,&#10;            isSpecial = true,&#10;            date = date&#10;        )&#10;&#10;        fileManager.downloadAndSavePdf(&#10;            url = pdfUrl,&#10;            fileName = &quot;special_schedule.pdf&quot;,&#10;            date = date&#10;        )&#10;    }&#10;&#10;    private suspend fun downloadRegularSchedules(urls: com.davidp799.patcotoday.data.models.ScheduleUrls) {&#10;        val downloads = listOf(&#10;            urls.weekdaysEastUrl to &quot;weekdays_east.csv&quot;,&#10;            urls.weekdaysWestUrl to &quot;weekdays_west.csv&quot;,&#10;            urls.saturdaysEastUrl to &quot;saturdays_east.csv&quot;,&#10;            urls.saturdaysWestUrl to &quot;saturdays_west.csv&quot;,&#10;            urls.sundaysEastUrl to &quot;sundays_east.csv&quot;,&#10;            urls.sundaysWestUrl to &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        downloads.forEach { (url, fileName) -&gt;&#10;            fileManager.downloadAndSaveFile(url, fileName)&#10;        }&#10;    }&#10;&#10;    private fun getCurrentDate(): String {&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        return dateFormat.format(Date())&#10;    }&#10;&#10;    fun getLastUpdateTimeFormatted(): String {&#10;        return fileManager.getLastUpdateTimeFormatted()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.davidp799.patcotoday.data.repository&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.davidp799.patcotoday.data.api.ScheduleApiService&#10;import com.davidp799.patcotoday.data.local.FileManager&#10;import com.davidp799.patcotoday.data.local.CsvScheduleParser&#10;import com.davidp799.patcotoday.data.models.ApiResponse&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.BuildConfig&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class ScheduleRepository(private val context: Context) {&#10;    val fileManager = FileManager(context)&#10;    private val csvParser = CsvScheduleParser(context)&#10;    private val apiService: ScheduleApiService&#10;&#10;    // API key now read from BuildConfig, which gets it from local.properties&#10;    private val apiKey = BuildConfig.API_KEY&#10;    private val baseUrl = &quot;https://pyy0z7hm81.execute-api.us-east-1.amazonaws.com/&quot;&#10;&#10;    init {&#10;        val retrofit = Retrofit.Builder()&#10;            .baseUrl(baseUrl)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;&#10;        apiService = retrofit.create(ScheduleApiService::class.java)&#10;    }&#10;&#10;    suspend fun fetchAndUpdateSchedules(): Result&lt;ApiResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Check if network operations are allowed based on mobile data settings&#10;                if (!NetworkUtils.shouldAllowNetworkOperation(context)) {&#10;                    withContext(Dispatchers.Main) {&#10;                        NetworkUtils.showMobileDataBlockedToast(context)&#10;                    }&#10;                    return@withContext Result.failure(Exception(&quot;Network operation blocked due to mobile data restrictions&quot;))&#10;                }&#10;&#10;                val today = getCurrentDate()&#10;                val lastUpdated = fileManager.getOldestLastModified()&#10;                val response = apiService.getSchedules(&#10;                    scheduleDate = today,&#10;                    lastUpdated = lastUpdated,&#10;                    apiKey = apiKey&#10;                )&#10;&#10;                if (response.isSuccessful) {&#10;                    val apiResponse = response.body()!!&#10;&#10;                    // Download special schedules if available&#10;                    apiResponse.specialSchedules?.let { special -&gt;&#10;                        downloadSpecialSchedules(special.scheduleDate, special.eastboundUrl, special.westboundUrl, special.pdfUrl)&#10;                    }&#10;&#10;                    // Download regular schedules if updated&#10;                    apiResponse.regularSchedules?.let { regular -&gt;&#10;                        if (regular.updated &amp;&amp; regular.urls != null) {&#10;                            downloadRegularSchedules(regular.urls)&#10;                        }&#10;                    }&#10;&#10;                    Result.success(apiResponse)&#10;                } else {&#10;                    Log.e(&quot;[fetchAndUpdateSchedules]&quot;, &quot;API call failed with code: ${response.code()}&quot;)&#10;                    Result.failure(Exception(&quot;API call failed: ${response.code()}&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[fetchAndUpdateSchedules]&quot;, &quot;API call exception: ${e.message}&quot;, e)&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun getScheduleForRoute(fromStation: String, toStation: String): List&lt;Arrival&gt; {&#10;        // First try to get from local files (downloaded from API)&#10;        val arrivals = csvParser.parseScheduleForRoute(fromStation, toStation)&#10;&#10;        if (arrivals.isNotEmpty()) {&#10;            return arrivals&#10;        }&#10;&#10;        // If no local data found, fall back to assets&#10;        val assetArrivals = csvParser.parseScheduleFromAssets(fromStation, toStation)&#10;        return assetArrivals&#10;    }&#10;&#10;    private suspend fun downloadSpecialSchedules(date: String, eastboundUrl: String, westboundUrl: String, pdfUrl: String) {&#10;        fileManager.downloadAndSaveFile(&#10;            url = eastboundUrl,&#10;            fileName = &quot;special_schedule_eastbound.csv&quot;,&#10;            isSpecial = true,&#10;            date = date&#10;        )&#10;&#10;        fileManager.downloadAndSaveFile(&#10;            url = westboundUrl,&#10;            fileName = &quot;special_schedule_westbound.csv&quot;,&#10;            isSpecial = true,&#10;            date = date&#10;        )&#10;&#10;        fileManager.downloadAndSavePdf(&#10;            url = pdfUrl,&#10;            fileName = &quot;special_schedule.pdf&quot;,&#10;            date = date&#10;        )&#10;    }&#10;&#10;    private suspend fun downloadRegularSchedules(urls: com.davidp799.patcotoday.data.models.ScheduleUrls) {&#10;        val downloads = listOf(&#10;            urls.weekdaysEastUrl to &quot;weekdays_east.csv&quot;,&#10;            urls.weekdaysWestUrl to &quot;weekdays_west.csv&quot;,&#10;            urls.saturdaysEastUrl to &quot;saturdays_east.csv&quot;,&#10;            urls.saturdaysWestUrl to &quot;saturdays_west.csv&quot;,&#10;            urls.sundaysEastUrl to &quot;sundays_east.csv&quot;,&#10;            urls.sundaysWestUrl to &quot;sundays_west.csv&quot;&#10;        )&#10;&#10;        downloads.forEach { (url, fileName) -&gt;&#10;            fileManager.downloadAndSaveFile(url, fileName)&#10;        }&#10;    }&#10;&#10;    private fun getCurrentDate(): String {&#10;        val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        return dateFormat.format(Date())&#10;    }&#10;&#10;    fun getLastUpdateTimeFormatted(): String {&#10;        return fileManager.getLastUpdateTimeFormatted()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>