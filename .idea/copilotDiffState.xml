<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.compose.compiler)&#10;}&#10;&#10;// Load local.properties&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.davidp799.patcotoday&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.davidp799.patcotoday&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 21&#10;        versionName = &quot;2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // For development, read from local.properties if available&#10;        val apiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$apiKey\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // Use local.properties for development&#10;            val devApiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$devApiKey\&quot;&quot;)&#10;        }&#10;        release {&#10;            // Use the production API key for release builds&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2\&quot;&quot;)&#10;            isMinifyEnabled = true&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    compilerOptions {&#10;        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_1_8)&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.material.icons.extended.android)&#10;&#10;    // Add Material Compose animations for transitions&#10;    implementation(libs.androidx.animation)&#10;    implementation(libs.androidx.material)&#10;&#10;    // Add networking and API dependencies&#10;    implementation(libs.retrofit)&#10;    implementation(libs.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.logging.interceptor)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.preference.ktx)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.core.splashscreen)&#10;&#10;    // Google Play Store review dependency&#10;    implementation(libs.play.review)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.compose.compiler)&#10;}&#10;&#10;// Load local.properties&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.davidp799.patcotoday&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.davidp799.patcotoday&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 21&#10;        versionName = &quot;2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // For development, read from local.properties if available&#10;        val apiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$apiKey\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // Use local.properties for development&#10;            val devApiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$devApiKey\&quot;&quot;)&#10;        }&#10;        release {&#10;            // Use the production API key for release builds&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2\&quot;&quot;)&#10;            isMinifyEnabled = true&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.material.icons.extended.android)&#10;&#10;    // Add Material Compose animations for transitions&#10;    implementation(libs.androidx.animation)&#10;    implementation(libs.androidx.material)&#10;&#10;    // Add networking and API dependencies&#10;    implementation(libs.retrofit)&#10;    implementation(libs.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.logging.interceptor)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.preference.ktx)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.core.splashscreen)&#10;&#10;    // Google Play Store review dependency&#10;    implementation(libs.play.review)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/MainActivity.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday&#10;&#10;import android.content.SharedPreferences&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.SystemBarStyle&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.preference.PreferenceManager&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.ui.components.BottomNavigationBar&#10;import com.davidp799.patcotoday.ui.components.SideNavigationRail&#10;import com.davidp799.patcotoday.ui.components.SpecialScheduleBottomSheet&#10;import com.davidp799.patcotoday.ui.components.TopNavigationBar&#10;import com.davidp799.patcotoday.ui.navigation.Navigation&#10;import com.davidp799.patcotoday.ui.screens.SchedulesScreenViewModel&#10;import com.davidp799.patcotoday.ui.theme.PatcoTodayTheme&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.utils.VersionCodeStore&#10;import com.davidp799.patcotoday.ui.whatsnew.WhatsNewScreen&#10;import com.davidp799.patcotoday.ui.welcome.WelcomeScreen&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;import com.google.android.play.core.review.ReviewException&#10;import com.google.android.play.core.review.ReviewManagerFactory&#10;import com.google.android.play.core.review.model.ReviewErrorCode&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity(), SharedPreferences.OnSharedPreferenceChangeListener {&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var isFirstRunComplete = mutableStateOf(false)&#10;    private var firstRunLoadingMessage = mutableStateOf(&quot;Loading schedules...&quot;)&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Install the splash screen&#10;        val splashScreen = installSplashScreen()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Keep splash screen visible until app is ready (but not during first launch loading screen)&#10;        splashScreen.setKeepOnScreenCondition {&#10;            !isFirstRunComplete.value&#10;        }&#10;&#10;        // Get theme preferences to configure system bars&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val themePreference = prefs.getString(&quot;device_theme&quot;, &quot;3&quot;)?.toInt() ?: 3&#10;        val isSystemInDarkTheme = resources.configuration.uiMode and&#10;            Configuration.UI_MODE_NIGHT_MASK ==&#10;            Configuration.UI_MODE_NIGHT_YES&#10;&#10;        // Determine if we should use dark theme&#10;        val useDarkTheme = when (themePreference) {&#10;            1 -&gt; false // Light theme&#10;            2 -&gt; true  // Dark theme&#10;            3 -&gt; isSystemInDarkTheme // Follow system&#10;            else -&gt; isSystemInDarkTheme&#10;        }&#10;&#10;        // Configure edge-to-edge with proper system bar styles&#10;        enableEdgeToEdge(&#10;            statusBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.BLACK)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.WHITE, android.graphics.Color.BLACK)&#10;            },&#10;            navigationBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.BLACK)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.WHITE, android.graphics.Color.BLACK)&#10;            }&#10;        )&#10;&#10;        // Initialize repository&#10;        scheduleRepository = ScheduleRepository(this)&#10;&#10;        // Register preference change listener&#10;        prefs.registerOnSharedPreferenceChangeListener(this)&#10;&#10;        // Handle first run logic completely before showing main UI&#10;        lifecycleScope.launch {&#10;            handleFirstRunAndDataLoading()&#10;        }&#10;&#10;        setContent {&#10;            PatcoTodayTheme {&#10;                var showWhatsNew by remember { mutableStateOf(false) }&#10;                var showWelcome by remember { mutableStateOf(false) }&#10;                val context = this&#10;&#10;                LaunchedEffect(Unit) {&#10;                    val currentVersionCode = BuildConfig.VERSION_CODE&#10;                    val savedVersionCode = VersionCodeStore.getVersionCode(context)&#10;&#10;                    // Check if this is a first-time user (no version saved)&#10;                    if (savedVersionCode == -1) {&#10;                        showWelcome = true&#10;                        // Start API call immediately for first-time users&#10;                        lifecycleScope.launch {&#10;                            scheduleRepository.fetchAndUpdateSchedules()&#10;                                .onSuccess { apiResponse -&gt;&#10;                                    // Check if regular schedules were updated&#10;                                    val regularSchedules = apiResponse.regularSchedules&#10;                                    if (regularSchedules == null) {&#10;                                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                                    }&#10;                                }&#10;                                .onFailure { error -&gt;&#10;                                    Log.e(&quot;[WelcomeScreen]&quot;, &quot;API call failed: ${error.message}&quot;)&#10;                                    // Show appropriate error message based on error type&#10;                                    val errorMessage = when (error) {&#10;                                        is UnknownHostException -&gt; {&#10;                                            &quot;No internet connection. Using offline schedules.&quot;&#10;                                        }&#10;                                        is SocketTimeoutException -&gt; {&#10;                                            &quot;Request timed out. Using offline schedules.&quot;&#10;                                        }&#10;                                        else -&gt; {&#10;                                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                                &quot;Server error. Using offline schedules.&quot;&#10;                                            } else {&#10;                                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                                } else {&#10;                                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;                                }&#10;                        }&#10;                    } else if (currentVersionCode &gt; savedVersionCode) {&#10;                        // Existing user with an update&#10;                        showWhatsNew = true&#10;                    }&#10;                }&#10;&#10;                when {&#10;                    showWelcome -&gt; {&#10;                        WelcomeScreen(onGetStarted = {&#10;                            showWelcome = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    showWhatsNew -&gt; {&#10;                        WhatsNewScreen(onDismiss = {&#10;                            showWhatsNew = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    else -&gt; {&#10;                        if (isFirstRunComplete.value) {&#10;                            MainScreen()&#10;                        } else {&#10;                            FirstRunLoadingScreen(loadingMessage = firstRunLoadingMessage.value)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleFirstRunAndDataLoading() {&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val isFirstRun = !prefs.getBoolean(&quot;first_run_completed&quot;, false)&#10;&#10;        if (isFirstRun) {&#10;            // Show appropriate loading message for first run&#10;            firstRunLoadingMessage.value = &quot;Downloading latest schedules...&quot;&#10;&#10;            // Perform first run API call and wait for completion&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Mark first run as completed&#10;                    prefs.edit().putBoolean(&quot;first_run_completed&quot;, true).apply()&#10;&#10;                    // Check if regular schedules were updated&#10;                    val regularSchedules = apiResponse.regularSchedules&#10;                    if (regularSchedules == null) {&#10;                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                    }&#10;&#10;                    // Request app review after successful data load&#10;                    requestReview()&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[checkIfFirstRun]&quot;, &quot;First run API call failed: ${error.message}&quot;)&#10;&#10;                    // Mark first run as completed anyway so UI can proceed with fallback data&#10;                    prefs.edit()&#10;                        .putBoolean(&quot;first_run_completed&quot;, true)&#10;                        .putBoolean(&quot;using_fallback_data&quot;, true)&#10;                        .apply()&#10;&#10;                    // Show appropriate error message based on error type&#10;                    val errorMessage = when (error) {&#10;                        is UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Using offline schedules.&quot;&#10;                        }&#10;                        is SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Using offline schedules.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                &quot;Server error. Using offline schedules.&quot;&#10;                            } else {&#10;                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                } else {&#10;                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;&#10;                    // Request app review even on API failure to track visits&#10;                    requestReview()&#10;                }&#10;        } else {&#10;            // Not first run, still make API call but don't block UI&#10;            lifecycleScope.launch {&#10;                scheduleRepository.fetchAndUpdateSchedules()&#10;                    .onSuccess { apiResponse -&gt;&#10;                        // Check if regular schedules were updated&#10;                        apiResponse.regularSchedules&#10;                        requestReview()&#10;                    }&#10;                    .onFailure { error -&gt;&#10;                        Log.e(&quot;[MainActivity]&quot;, &quot;Background API call failed: ${error.message}&quot;)&#10;                        // Don't show error messages for background updates unless critical&#10;                        requestReview()&#10;                    }&#10;            }&#10;        }&#10;&#10;        // Mark first run as complete so UI can be shown&#10;        isFirstRunComplete.value = true&#10;    }&#10;&#10;    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {&#10;        when (key) {&#10;            &quot;device_theme&quot;, &quot;dynamic_colors&quot; -&gt; {&#10;                // Recreate activity to apply theme changes&#10;                recreate()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        PreferenceManager.getDefaultSharedPreferences(this)&#10;            .unregisterOnSharedPreferenceChangeListener(this)&#10;    }&#10;&#10;    private fun showToast(message: String) {&#10;        runOnUiThread {&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Request Google Play Store app review&#10;    private fun requestReview() {&#10;        val prefVisitNumber = &quot;visit_number&quot;&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val visitNumber = prefs.getInt(prefVisitNumber, 0)&#10;        val sharedPreferencesEditor = prefs.edit()&#10;&#10;        if (visitNumber % 10 == 0) {&#10;            val reviewManager = ReviewManagerFactory.create(this)&#10;            val requestReviewFlow = reviewManager.requestReviewFlow()&#10;            requestReviewFlow.addOnCompleteListener {&#10;                if (it.isSuccessful) {&#10;                    val reviewInfo = it.result&#10;                    val reviewFlow = reviewManager.launchReviewFlow(this, reviewInfo)&#10;                    reviewFlow.addOnCompleteListener {&#10;                        sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                    }&#10;                } else {&#10;                    @ReviewErrorCode val reviewErrorCode = (it.exception as? ReviewException)?.errorCode&#10;                    Log.e(&#10;                        &quot;[requestReview]&quot;,&#10;                        &quot;reviewErrorCode = $reviewErrorCode&quot;&#10;                    )&#10;                    // Still increment visit number even if review request failed&#10;                    sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                }&#10;            }&#10;        } else {&#10;            sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FirstRunLoadingScreen(loadingMessage: String) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            CircularProgressIndicator(&#10;                modifier = Modifier.size(48.dp),&#10;                strokeWidth = 4.dp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = loadingMessage,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen() {&#10;    val navController = rememberNavController()&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    // Create ViewModel instance once and reuse it&#10;    val schedulesViewModel: SchedulesScreenViewModel = viewModel()&#10;    val schedulesUiState by schedulesViewModel.uiState.collectAsState()&#10;&#10;    // Set up toast callback for the ViewModel&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    LaunchedEffect(Unit) {&#10;        schedulesViewModel.setShowToastCallback { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Animate blur effect when refreshing schedules&#10;    val blurRadius by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 8f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_blur_effect&quot;&#10;    )&#10;&#10;    // Animate overlay alpha when refreshing schedules&#10;    val overlayAlpha by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 0.3f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_overlay_fade&quot;&#10;    )&#10;&#10;    // Detect screen orientation&#10;    val configuration = LocalConfiguration.current&#10;    val isPortrait = configuration.orientation == Configuration.ORIENTATION_PORTRAIT&#10;&#10;    // Bottom sheet state - for landscape mode only&#10;    val landscapeBottomSheetState = rememberStandardBottomSheetState(&#10;        initialValue = if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet)&#10;            SheetValue.PartiallyExpanded else SheetValue.Hidden,&#10;        skipHiddenState = false&#10;    )&#10;&#10;    // Handle bottom sheet state changes for landscape&#10;    LaunchedEffect(isPortrait, currentRoute, schedulesUiState.showSpecialScheduleSheet) {&#10;        if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet &amp;&amp; !schedulesUiState.hasUserDismissedSheet) {&#10;            landscapeBottomSheetState.partialExpand()&#10;        } else {&#10;            landscapeBottomSheetState.hide()&#10;        }&#10;    }&#10;&#10;    // Handle when user manually dismisses sheet in landscape&#10;    LaunchedEffect(landscapeBottomSheetState.targetValue) {&#10;        if (landscapeBottomSheetState.targetValue == SheetValue.Hidden &amp;&amp;&#10;            !isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet) {&#10;            schedulesViewModel.dismissSpecialScheduleSheet()&#10;        }&#10;    }&#10;&#10;    if (isPortrait) {&#10;        // Portrait mode: Bottom sheet contained within main content area&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            Scaffold(&#10;                topBar = {&#10;                    TopNavigationBar(&#10;                        navController = navController,&#10;                        onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                            { schedulesViewModel.refreshSchedules() }&#10;                        } else null,&#10;                        isRefreshing = schedulesUiState.isRefreshing&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    BottomNavigationBar(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;                },&#10;                modifier = Modifier.blur(radius = blurRadius.dp)&#10;            ) { innerPadding -&gt;&#10;                // Portrait mode: Use SchedulesScreen with its own bottom sheet for schedules screen&#10;                Navigation(&#10;                    navController = navController,&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                    useInternalBottomSheet = true // Flag to tell SchedulesScreen to use its own bottom sheet&#10;                )&#10;            }&#10;&#10;            // Blur overlay when refreshing schedules&#10;            if (overlayAlpha &gt; 0f) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Color.Black.copy(alpha = overlayAlpha)&#10;                        )&#10;                )&#10;            }&#10;&#10;            // Loading indicator on top of blur&#10;            if (schedulesUiState.isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(48.dp),&#10;                        strokeWidth = 4.dp,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    } else {&#10;        // Landscape mode: Bottom sheet at top level spans full screen&#10;        BottomSheetScaffold(&#10;            scaffoldState = rememberBottomSheetScaffoldState(bottomSheetState = landscapeBottomSheetState),&#10;            sheetContent = {&#10;                if (currentRoute == &quot;schedules&quot;) {&#10;                    SpecialScheduleBottomSheet(&#10;                        specialScheduleState = schedulesUiState.specialScheduleState,&#10;                        onViewSchedule = { schedulesViewModel.openSpecialSchedulePdf() }&#10;                    )&#10;                } else {&#10;                    // Empty content when not on schedules screen&#10;                    Spacer(modifier = Modifier.height(1.dp))&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .blur(radius = blurRadius.dp)&#10;                ) {&#10;                    // Side navigation rail&#10;                    SideNavigationRail(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;&#10;                    // Main content area&#10;                    Scaffold(&#10;                        topBar = {&#10;                            TopNavigationBar(&#10;                                navController = navController,&#10;                                onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                                    { schedulesViewModel.refreshSchedules() }&#10;                                } else null,&#10;                                isRefreshing = schedulesUiState.isRefreshing&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) { innerPadding -&gt;&#10;                        Navigation(&#10;                            navController = navController,&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                            useInternalBottomSheet = false // Flag to tell SchedulesScreen NOT to use its own bottom sheet&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Blur overlay when refreshing schedules&#10;                if (overlayAlpha &gt; 0f) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Color.Black.copy(alpha = overlayAlpha)&#10;                            )&#10;                    )&#10;                }&#10;&#10;                // Loading indicator on top of blur&#10;                if (schedulesUiState.isRefreshing) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(48.dp),&#10;                            strokeWidth = 4.dp,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    PatcoTodayTheme {&#10;        MainScreen()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.davidp799.patcotoday&#10;&#10;import android.content.SharedPreferences&#10;import android.content.res.Configuration&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.SystemBarStyle&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.preference.PreferenceManager&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.ui.components.BottomNavigationBar&#10;import com.davidp799.patcotoday.ui.components.SideNavigationRail&#10;import com.davidp799.patcotoday.ui.components.SpecialScheduleBottomSheet&#10;import com.davidp799.patcotoday.ui.components.TopNavigationBar&#10;import com.davidp799.patcotoday.ui.navigation.Navigation&#10;import com.davidp799.patcotoday.ui.screens.SchedulesScreenViewModel&#10;import com.davidp799.patcotoday.ui.theme.PatcoTodayTheme&#10;import com.davidp799.patcotoday.utils.NetworkUtils&#10;import com.davidp799.patcotoday.utils.VersionCodeStore&#10;import com.davidp799.patcotoday.ui.whatsnew.WhatsNewScreen&#10;import com.davidp799.patcotoday.ui.welcome.WelcomeScreen&#10;import java.net.SocketTimeoutException&#10;import java.net.UnknownHostException&#10;import com.google.android.play.core.review.ReviewException&#10;import com.google.android.play.core.review.ReviewManagerFactory&#10;import com.google.android.play.core.review.model.ReviewErrorCode&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity(), SharedPreferences.OnSharedPreferenceChangeListener {&#10;&#10;    private lateinit var scheduleRepository: ScheduleRepository&#10;    private var isFirstRunComplete = mutableStateOf(false)&#10;    private var firstRunLoadingMessage = mutableStateOf(&quot;Loading schedules...&quot;)&#10;    // Add a CompletableDeferred to track API call completion&#10;    private val apiCallCompletion = CompletableDeferred&lt;Boolean&gt;()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Install the splash screen&#10;        val splashScreen = installSplashScreen()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Keep splash screen visible until app is ready (but not during first launch loading screen)&#10;        splashScreen.setKeepOnScreenCondition {&#10;            !isFirstRunComplete.value&#10;        }&#10;&#10;        // Get theme preferences to configure system bars&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val themePreference = prefs.getString(&quot;device_theme&quot;, &quot;3&quot;)?.toInt() ?: 3&#10;        val isSystemInDarkTheme = resources.configuration.uiMode and&#10;            Configuration.UI_MODE_NIGHT_MASK ==&#10;            Configuration.UI_MODE_NIGHT_YES&#10;&#10;        // Determine if we should use dark theme&#10;        val useDarkTheme = when (themePreference) {&#10;            1 -&gt; false // Light theme&#10;            2 -&gt; true  // Dark theme&#10;            3 -&gt; isSystemInDarkTheme // Follow system&#10;            else -&gt; isSystemInDarkTheme&#10;        }&#10;&#10;        // Configure edge-to-edge with proper system bar styles&#10;        enableEdgeToEdge(&#10;            statusBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.BLACK)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.WHITE, android.graphics.Color.BLACK)&#10;            },&#10;            navigationBarStyle = if (useDarkTheme) {&#10;                SystemBarStyle.dark(android.graphics.Color.BLACK)&#10;            } else {&#10;                SystemBarStyle.light(android.graphics.Color.WHITE, android.graphics.Color.BLACK)&#10;            }&#10;        )&#10;&#10;        // Initialize repository&#10;        scheduleRepository = ScheduleRepository(this)&#10;&#10;        // Register preference change listener&#10;        prefs.registerOnSharedPreferenceChangeListener(this)&#10;&#10;        // Handle first run logic completely before showing main UI&#10;        lifecycleScope.launch {&#10;            handleFirstRunAndDataLoading()&#10;        }&#10;&#10;        setContent {&#10;            PatcoTodayTheme {&#10;                var showWhatsNew by remember { mutableStateOf(false) }&#10;                var showWelcome by remember { mutableStateOf(false) }&#10;                val context = this&#10;&#10;                LaunchedEffect(Unit) {&#10;                    val currentVersionCode = BuildConfig.VERSION_CODE&#10;                    val savedVersionCode = VersionCodeStore.getVersionCode(context)&#10;&#10;                    // Check if this is a first-time user (no version saved)&#10;                    if (savedVersionCode == -1) {&#10;                        showWelcome = true&#10;                        // Start API call immediately for first-time users&#10;                        lifecycleScope.launch {&#10;                            scheduleRepository.fetchAndUpdateSchedules()&#10;                                .onSuccess { apiResponse -&gt;&#10;                                    // Check if regular schedules were updated&#10;                                    val regularSchedules = apiResponse.regularSchedules&#10;                                    if (regularSchedules == null) {&#10;                                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                                    }&#10;                                }&#10;                                .onFailure { error -&gt;&#10;                                    Log.e(&quot;[WelcomeScreen]&quot;, &quot;API call failed: ${error.message}&quot;)&#10;                                    // Show appropriate error message based on error type&#10;                                    val errorMessage = when (error) {&#10;                                        is UnknownHostException -&gt; {&#10;                                            &quot;No internet connection. Using offline schedules.&quot;&#10;                                        }&#10;                                        is SocketTimeoutException -&gt; {&#10;                                            &quot;Request timed out. Using offline schedules.&quot;&#10;                                        }&#10;                                        else -&gt; {&#10;                                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                                &quot;Server error. Using offline schedules.&quot;&#10;                                            } else {&#10;                                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                                } else {&#10;                                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;                                }&#10;                        }&#10;                    } else if (currentVersionCode &gt; savedVersionCode) {&#10;                        // Existing user with an update&#10;                        showWhatsNew = true&#10;                    }&#10;                }&#10;&#10;                when {&#10;                    showWelcome -&gt; {&#10;                        WelcomeScreen(onGetStarted = {&#10;                            showWelcome = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    showWhatsNew -&gt; {&#10;                        WhatsNewScreen(onDismiss = {&#10;                            showWhatsNew = false&#10;                            VersionCodeStore.setVersionCode(context, BuildConfig.VERSION_CODE)&#10;                        })&#10;                    }&#10;                    else -&gt; {&#10;                        if (isFirstRunComplete.value) {&#10;                            MainScreen()&#10;                        } else {&#10;                            FirstRunLoadingScreen(loadingMessage = firstRunLoadingMessage.value)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleFirstRunAndDataLoading() {&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val isFirstRun = !prefs.getBoolean(&quot;first_run_completed&quot;, false)&#10;&#10;        if (isFirstRun) {&#10;            // Show appropriate loading message for first run&#10;            firstRunLoadingMessage.value = &quot;Downloading latest schedules...&quot;&#10;&#10;            // Perform first run API call and wait for completion&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Mark first run as completed&#10;                    prefs.edit().putBoolean(&quot;first_run_completed&quot;, true).apply()&#10;&#10;                    // Check if regular schedules were updated&#10;                    val regularSchedules = apiResponse.regularSchedules&#10;                    if (regularSchedules == null) {&#10;                        showToast(&quot;Schedule data loaded from cache&quot;)&#10;                    }&#10;&#10;                    // Request app review after successful data load&#10;                    requestReview()&#10;                    &#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[checkIfFirstRun]&quot;, &quot;First run API call failed: ${error.message}&quot;)&#10;&#10;                    // Mark first run as completed anyway so UI can proceed with fallback data&#10;                    prefs.edit()&#10;                        .putBoolean(&quot;first_run_completed&quot;, true)&#10;                        .putBoolean(&quot;using_fallback_data&quot;, true)&#10;                        .apply()&#10;&#10;                    // Show appropriate error message based on error type&#10;                    val errorMessage = when (error) {&#10;                        is UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Using offline schedules.&quot;&#10;                        }&#10;                        is SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Using offline schedules.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            if (error.message?.contains(&quot;404&quot;) == true) {&#10;                                &quot;Schedule service unavailable. Using offline schedules.&quot;&#10;                            } else if (error.message?.contains(&quot;500&quot;) == true) {&#10;                                &quot;Server error. Using offline schedules.&quot;&#10;                            } else {&#10;                                if (NetworkUtils.isOnMobileData(this@MainActivity) &amp;&amp;&#10;                                    !NetworkUtils.isDownloadOnMobileDataEnabled(this@MainActivity)) {&#10;                                    &quot;Download on mobile data disabled. Using offline schedules.&quot;&#10;                                } else {&#10;                                    &quot;Failed to download schedules. Using offline data.&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    if (errorMessage.isNotEmpty()) showToast(errorMessage)&#10;&#10;                    // Request app review even on API failure to track visits&#10;                    requestReview()&#10;                    &#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        } else {&#10;            // Not first run, but still wait for API call to complete before showing UI&#10;            scheduleRepository.fetchAndUpdateSchedules()&#10;                .onSuccess { apiResponse -&gt;&#10;                    // Check if regular schedules were updated&#10;                    apiResponse.regularSchedules&#10;                    requestReview()&#10;                    &#10;                    // Signal API call completion&#10;                    apiCallCompletion.complete(true)&#10;                }&#10;                .onFailure { error -&gt;&#10;                    Log.e(&quot;[MainActivity]&quot;, &quot;Background API call failed: ${error.message}&quot;)&#10;                    // Don't show error messages for background updates unless critical&#10;                    requestReview()&#10;                    &#10;                    // Signal API call completion even on failure&#10;                    apiCallCompletion.complete(false)&#10;                }&#10;        }&#10;&#10;        // Mark first run as complete so UI can be shown&#10;        isFirstRunComplete.value = true&#10;    }&#10;&#10;    // Add method to get API call completion status&#10;    fun getApiCallCompletion(): CompletableDeferred&lt;Boolean&gt; = apiCallCompletion&#10;&#10;    override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {&#10;        when (key) {&#10;            &quot;device_theme&quot;, &quot;dynamic_colors&quot; -&gt; {&#10;                // Recreate activity to apply theme changes&#10;                recreate()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        PreferenceManager.getDefaultSharedPreferences(this)&#10;            .unregisterOnSharedPreferenceChangeListener(this)&#10;    }&#10;&#10;    private fun showToast(message: String) {&#10;        runOnUiThread {&#10;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Request Google Play Store app review&#10;    private fun requestReview() {&#10;        val prefVisitNumber = &quot;visit_number&quot;&#10;        val prefs = PreferenceManager.getDefaultSharedPreferences(this)&#10;        val visitNumber = prefs.getInt(prefVisitNumber, 0)&#10;        val sharedPreferencesEditor = prefs.edit()&#10;&#10;        if (visitNumber % 10 == 0) {&#10;            val reviewManager = ReviewManagerFactory.create(this)&#10;            val requestReviewFlow = reviewManager.requestReviewFlow()&#10;            requestReviewFlow.addOnCompleteListener {&#10;                if (it.isSuccessful) {&#10;                    val reviewInfo = it.result&#10;                    val reviewFlow = reviewManager.launchReviewFlow(this, reviewInfo)&#10;                    reviewFlow.addOnCompleteListener {&#10;                        sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                    }&#10;                } else {&#10;                    @ReviewErrorCode val reviewErrorCode = (it.exception as? ReviewException)?.errorCode&#10;                    Log.e(&#10;                        &quot;[requestReview]&quot;,&#10;                        &quot;reviewErrorCode = $reviewErrorCode&quot;&#10;                    )&#10;                    // Still increment visit number even if review request failed&#10;                    sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;                }&#10;            }&#10;        } else {&#10;            sharedPreferencesEditor.putInt(prefVisitNumber, visitNumber + 1).apply()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FirstRunLoadingScreen(loadingMessage: String) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            CircularProgressIndicator(&#10;                modifier = Modifier.size(48.dp),&#10;                strokeWidth = 4.dp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;            Text(&#10;                text = loadingMessage,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onBackground,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScreen() {&#10;    val navController = rememberNavController()&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    // Create ViewModel instance once and reuse it&#10;    val schedulesViewModel: SchedulesScreenViewModel = viewModel()&#10;    val schedulesUiState by schedulesViewModel.uiState.collectAsState()&#10;&#10;    // Set up toast callback for the ViewModel&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;    LaunchedEffect(Unit) {&#10;        schedulesViewModel.setShowToastCallback { message -&gt;&#10;            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    // Animate blur effect when refreshing schedules&#10;    val blurRadius by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 8f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_blur_effect&quot;&#10;    )&#10;&#10;    // Animate overlay alpha when refreshing schedules&#10;    val overlayAlpha by animateFloatAsState(&#10;        targetValue = if (currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.isRefreshing) 0.3f else 0f,&#10;        animationSpec = tween(&#10;            durationMillis = 300,&#10;            easing = FastOutSlowInEasing&#10;        ),&#10;        label = &quot;main_overlay_fade&quot;&#10;    )&#10;&#10;    // Detect screen orientation&#10;    val configuration = LocalConfiguration.current&#10;    val isPortrait = configuration.orientation == Configuration.ORIENTATION_PORTRAIT&#10;&#10;    // Bottom sheet state - for landscape mode only&#10;    val landscapeBottomSheetState = rememberStandardBottomSheetState(&#10;        initialValue = if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet)&#10;            SheetValue.PartiallyExpanded else SheetValue.Hidden,&#10;        skipHiddenState = false&#10;    )&#10;&#10;    // Handle bottom sheet state changes for landscape&#10;    LaunchedEffect(isPortrait, currentRoute, schedulesUiState.showSpecialScheduleSheet) {&#10;        if (!isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet &amp;&amp; !schedulesUiState.hasUserDismissedSheet) {&#10;            landscapeBottomSheetState.partialExpand()&#10;        } else {&#10;            landscapeBottomSheetState.hide()&#10;        }&#10;    }&#10;&#10;    // Handle when user manually dismisses sheet in landscape&#10;    LaunchedEffect(landscapeBottomSheetState.targetValue) {&#10;        if (landscapeBottomSheetState.targetValue == SheetValue.Hidden &amp;&amp;&#10;            !isPortrait &amp;&amp; currentRoute == &quot;schedules&quot; &amp;&amp; schedulesUiState.showSpecialScheduleSheet) {&#10;            schedulesViewModel.dismissSpecialScheduleSheet()&#10;        }&#10;    }&#10;&#10;    if (isPortrait) {&#10;        // Portrait mode: Bottom sheet contained within main content area&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            Scaffold(&#10;                topBar = {&#10;                    TopNavigationBar(&#10;                        navController = navController,&#10;                        onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                            { schedulesViewModel.refreshSchedules() }&#10;                        } else null,&#10;                        isRefreshing = schedulesUiState.isRefreshing&#10;                    )&#10;                },&#10;                bottomBar = {&#10;                    BottomNavigationBar(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;                },&#10;                modifier = Modifier.blur(radius = blurRadius.dp)&#10;            ) { innerPadding -&gt;&#10;                // Portrait mode: Use SchedulesScreen with its own bottom sheet for schedules screen&#10;                Navigation(&#10;                    navController = navController,&#10;                    modifier = Modifier.padding(innerPadding),&#10;                    schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                    useInternalBottomSheet = true // Flag to tell SchedulesScreen to use its own bottom sheet&#10;                )&#10;            }&#10;&#10;            // Blur overlay when refreshing schedules&#10;            if (overlayAlpha &gt; 0f) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(&#10;                            Color.Black.copy(alpha = overlayAlpha)&#10;                        )&#10;                )&#10;            }&#10;&#10;            // Loading indicator on top of blur&#10;            if (schedulesUiState.isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(48.dp),&#10;                        strokeWidth = 4.dp,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    } else {&#10;        // Landscape mode: Bottom sheet at top level spans full screen&#10;        BottomSheetScaffold(&#10;            scaffoldState = rememberBottomSheetScaffoldState(bottomSheetState = landscapeBottomSheetState),&#10;            sheetContent = {&#10;                if (currentRoute == &quot;schedules&quot;) {&#10;                    SpecialScheduleBottomSheet(&#10;                        specialScheduleState = schedulesUiState.specialScheduleState,&#10;                        onViewSchedule = { schedulesViewModel.openSpecialSchedulePdf() }&#10;                    )&#10;                } else {&#10;                    // Empty content when not on schedules screen&#10;                    Spacer(modifier = Modifier.height(1.dp))&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .blur(radius = blurRadius.dp)&#10;                ) {&#10;                    // Side navigation rail&#10;                    SideNavigationRail(&#10;                        navController = navController,&#10;                        onSchedulesReselected = { schedulesViewModel.onSchedulesScreenReselected() }&#10;                    )&#10;&#10;                    // Main content area&#10;                    Scaffold(&#10;                        topBar = {&#10;                            TopNavigationBar(&#10;                                navController = navController,&#10;                                onRefreshClick = if (currentRoute == &quot;schedules&quot;) {&#10;                                    { schedulesViewModel.refreshSchedules() }&#10;                                } else null,&#10;                                isRefreshing = schedulesUiState.isRefreshing&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) { innerPadding -&gt;&#10;                        Navigation(&#10;                            navController = navController,&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            schedulesViewModel = if (currentRoute == &quot;schedules&quot;) schedulesViewModel else null,&#10;                            useInternalBottomSheet = false // Flag to tell SchedulesScreen NOT to use its own bottom sheet&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Blur overlay when refreshing schedules&#10;                if (overlayAlpha &gt; 0f) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Color.Black.copy(alpha = overlayAlpha)&#10;                            )&#10;                    )&#10;                }&#10;&#10;                // Loading indicator on top of blur&#10;                if (schedulesUiState.isRefreshing) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(48.dp),&#10;                            strokeWidth = 4.dp,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    PatcoTodayTheme {&#10;        MainScreen()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/ui/screens/SchedulesScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/ui/screens/SchedulesScreenViewModel.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday.ui.screens&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;enum class SpecialScheduleState {&#10;    NONE,           // No special schedules found for today&#10;    AVAILABLE,      // Special schedules are available&#10;    NETWORK_ERROR,  // Failed to check for special schedules due to network issues&#10;    LOADING         // Currently checking for special schedules&#10;}&#10;&#10;data class SchedulesUiState(&#10;    val isLoading: Boolean = true,&#10;    val arrivals: List&lt;Arrival&gt; = emptyList(),&#10;    val fromStation: String = &quot;Lindenwold&quot;,&#10;    val toStation: String = &quot;1516th &amp; Locust&quot;,&#10;    val scrollToIndex: Int = 0,&#10;    val errorMessage: String? = null,&#10;    val hasSpecialSchedule: Boolean = false,&#10;    val specialScheduleState: SpecialScheduleState = SpecialScheduleState.LOADING,&#10;    val isRefreshing: Boolean = false,&#10;    val lastRefreshTime: Long = 0L,&#10;    val isSpamming: Boolean = false,&#10;    val lastClickTime: Long = 0L,&#10;    val spamModeStartTime: Long = 0L,&#10;    val showSpecialScheduleSheet: Boolean = false,&#10;    val hasUserDismissedSheet: Boolean = false&#10;)&#10;&#10;class SchedulesScreenViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = ScheduleRepository(application)&#10;&#10;    private val _uiState = MutableStateFlow(SchedulesUiState())&#10;    val uiState: StateFlow&lt;SchedulesUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Callback for showing toast messages&#10;    private var showToastCallback: ((String) -&gt; Unit)? = null&#10;&#10;    val stationOptions = listOf(&#10;        &quot;Lindenwold&quot;,&#10;        &quot;Ashland&quot;,&#10;        &quot;Woodcrest&quot;,&#10;        &quot;Haddonfield&quot;,&#10;        &quot;Westmont&quot;,&#10;        &quot;Collingswood&quot;,&#10;        &quot;Ferry Avenue&quot;,&#10;        &quot;Broadway&quot;,&#10;        &quot;City Hall&quot;,&#10;        &quot;Franklin Square&quot;,&#10;        &quot;8th &amp; Market&quot;,&#10;        &quot;910th &amp; Locust&quot;,&#10;        &quot;1213th &amp; Locust&quot;,&#10;        &quot;1516th &amp; Locust&quot;&#10;    )&#10;&#10;    init {&#10;        loadScheduleData()&#10;    }&#10;&#10;    private fun loadScheduleData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)&#10;&#10;            // Only get schedule data from local storage, no API call&#10;            val arrivals = repository.getScheduleForRoute(&#10;                fromStation = _uiState.value.fromStation,&#10;                toStation = _uiState.value.toStation&#10;            )&#10;&#10;            // Check special schedule status&#10;            val specialScheduleState = checkSpecialScheduleStatus()&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                arrivals = arrivals,&#10;                hasSpecialSchedule = specialScheduleState == SpecialScheduleState.AVAILABLE,&#10;                specialScheduleState = specialScheduleState,&#10;                showSpecialScheduleSheet = !_uiState.value.hasUserDismissedSheet,&#10;                scrollToIndex = findNextArrival(arrivals),&#10;                errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun checkSpecialScheduleStatus(): SpecialScheduleState {&#10;        return try {&#10;            val context = getApplication&lt;Application&gt;()&#10;            val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;&#10;            // Check if special schedule files exist for today&#10;            val specialDir = java.io.File(context.filesDir, &quot;schedules/special/$currentDate&quot;)&#10;            val pdfFile = java.io.File(specialDir, &quot;special_schedule.pdf&quot;)&#10;            val eastboundFile = java.io.File(specialDir, &quot;special_schedule_eastbound.csv&quot;)&#10;            val westboundFile = java.io.File(specialDir, &quot;special_schedule_westbound.csv&quot;)&#10;&#10;            val hasSpecialFiles = pdfFile.exists() || eastboundFile.exists() || westboundFile.exists()&#10;&#10;            if (hasSpecialFiles) {&#10;                SpecialScheduleState.AVAILABLE&#10;            } else {&#10;                SpecialScheduleState.NONE&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;[checkSpecialScheduleStatus]&quot;, &quot;Error checking special schedule status: ${e.message}&quot;)&#10;            SpecialScheduleState.NETWORK_ERROR&#10;        }&#10;    }&#10;&#10;    fun updateFromStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(fromStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun updateToStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(toStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun reverseStations() {&#10;        val currentFrom = _uiState.value.fromStation&#10;        val currentTo = _uiState.value.toStation&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            fromStation = currentTo,&#10;            toStation = currentFrom&#10;        )&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun refreshSchedules() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val currentState = _uiState.value&#10;&#10;        // Check if we're currently in spam mode and if enough time has passed to exit&#10;        if (currentState.isSpamming) {&#10;            val timeSinceSpamStart = currentTime - currentState.spamModeStartTime&#10;            if (timeSinceSpamStart &gt;= 5000L) {&#10;                _uiState.value = currentState.copy(&#10;                    isSpamming = false,&#10;                    lastClickTime = currentTime&#10;                )&#10;                // Continue with normal refresh logic below&#10;            } else {&#10;                _uiState.value = currentState.copy(isRefreshing = true)&#10;&#10;                // Fake loading time (1-2 seconds)&#10;                viewModelScope.launch {&#10;                    kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                    _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        val timeSinceLastClick = currentTime - currentState.lastClickTime&#10;&#10;        // Check if user is spam clicking (more than 3 clicks in 3 seconds)&#10;        val isSpamClick = timeSinceLastClick &lt; 1000L &amp;&amp; currentState.lastClickTime &gt; 0&#10;&#10;        // Update click time&#10;        _uiState.value = currentState.copy(lastClickTime = currentTime)&#10;&#10;        // If spam clicking detected, enter spam mode&#10;        if (isSpamClick &amp;&amp; !currentState.isSpamming) {&#10;            _uiState.value = _uiState.value.copy(&#10;                isSpamming = true,&#10;                spamModeStartTime = currentTime,&#10;                isRefreshing = true&#10;            )&#10;&#10;            // Fake loading time and return&#10;            viewModelScope.launch {&#10;                kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Normal refresh logic&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isRefreshing = true, errorMessage = null)&#10;&#10;            try {&#10;                // Make API call to fetch and update schedules&#10;                val result = repository.fetchAndUpdateSchedules()&#10;&#10;                result.onSuccess { apiResponse -&gt;&#10;                    // Check if schedules were actually updated&#10;                    val schedulesWereUpdated = apiResponse.regularSchedules?.updated == true&#10;&#10;                    // After API call, reload the schedule data from local storage&#10;                    val arrivals = repository.getScheduleForRoute(&#10;                        fromStation = _uiState.value.fromStation,&#10;                        toStation = _uiState.value.toStation&#10;                    )&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        arrivals = arrivals,&#10;                        scrollToIndex = findNextArrival(arrivals),&#10;                        errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null,&#10;                        lastRefreshTime = System.currentTimeMillis()&#10;                    )&#10;&#10;                    // Show appropriate toast message&#10;                    if (!schedulesWereUpdated) {&#10;                        showToastCallback?.invoke(&quot;Your schedules are up to date.&quot;)&#10;                    }&#10;                }.onFailure { error -&gt;&#10;                    Log.e(&quot;[refreshSchedules]&quot;, &quot;Manual refresh failed: ${error.message}&quot;)&#10;&#10;                    // Determine the appropriate error message based on the failure reason&#10;                    val context = getApplication&lt;Application&gt;()&#10;                    val errorMessage = when {&#10;                        // Check if failure is due to mobile data restrictions&#10;                        com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                        !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                            &quot;&quot;&#10;                        }&#10;                        // Other network-related errors&#10;                        error is java.net.UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Please check your network and try again.&quot;&#10;                        }&#10;                        error is java.net.SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;404&quot;) == true -&gt; {&#10;                            &quot;Schedule service temporarily unavailable. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;500&quot;) == true -&gt; {&#10;                            &quot;Server error occurred. Please try again later.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            &quot;Failed to update schedules. Please try again later.&quot;&#10;                        }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        errorMessage = &quot;Failed to refresh schedules: ${error.message}&quot;&#10;                    )&#10;&#10;                    // Show specific toast message&#10;                    if (errorMessage.isNotEmpty()) showToastCallback?.invoke(errorMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[refreshSchedules]&quot;, &quot;Exception during manual refresh: ${e.message}&quot;, e)&#10;&#10;                // Determine the appropriate error message for exceptions&#10;                val context = getApplication&lt;Application&gt;()&#10;                val errorMessage = when {&#10;                    // Check if exception is due to mobile data restrictions&#10;                    com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                    !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                        &quot;Download on mobile data is disabled. Enable it in settings or connect to Wi-Fi to refresh schedules.&quot;&#10;                    }&#10;                    else -&gt; {&#10;                        &quot;Failed to update schedules. Please try again later.&quot;&#10;                    }&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isRefreshing = false,&#10;                    errorMessage = &quot;Failed to refresh schedules&quot;&#10;                )&#10;&#10;                // Show specific toast message&#10;                showToastCallback?.invoke(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findNextArrival(arrivals: List&lt;Arrival&gt;): Int {&#10;        if (arrivals.isEmpty()) return 0&#10;&#10;        val currentTime = java.util.Calendar.getInstance()&#10;        val currentHour = currentTime.get(java.util.Calendar.HOUR_OF_DAY)&#10;        val currentMinute = currentTime.get(java.util.Calendar.MINUTE)&#10;        val currentTotalMinutes = currentHour * 60 + currentMinute&#10;&#10;        for (i in arrivals.indices) {&#10;            try {&#10;                val arrivalTime = arrivals[i].arrivalTime&#10;                    .replace(&quot; AM&quot;, &quot;&quot;)&#10;                    .replace(&quot; PM&quot;, &quot;&quot;)&#10;&#10;                val parts = arrivalTime.split(&quot;:&quot;)&#10;                val hour = parts[0].toInt()&#10;                val minute = parts[1].toInt()&#10;&#10;                // Convert to 24-hour format&#10;                val hour24 = if (arrivals[i].arrivalTime.contains(&quot;PM&quot;) &amp;&amp; hour != 12) {&#10;                    hour + 12&#10;                } else if (arrivals[i].arrivalTime.contains(&quot;AM&quot;) &amp;&amp; hour == 12) {&#10;                    0&#10;                } else {&#10;                    hour&#10;                }&#10;&#10;                val arrivalTotalMinutes = hour24 * 60 + minute&#10;&#10;                // Return index of first arrival that's in the future&#10;                if (arrivalTotalMinutes &gt;= currentTotalMinutes) {&#10;                    return i&#10;                }&#10;            } catch (e: Exception) {&#10;                continue&#10;            }&#10;        }&#10;&#10;        return 0 // Default to first item if no future arrivals found&#10;    }&#10;&#10;    fun dismissSpecialScheduleSheet() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSpecialScheduleSheet = false,&#10;            hasUserDismissedSheet = true&#10;        )&#10;    }&#10;&#10;    fun openSpecialSchedulePdf() {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val pdfFile = java.io.File(context.filesDir, &quot;schedules/special/$currentDate/special_schedule.pdf&quot;)&#10;&#10;        if (pdfFile.exists()) {&#10;            try {&#10;                val uri = androidx.core.content.FileProvider.getUriForFile(&#10;                    context,&#10;                    &quot;${context.packageName}.fileprovider&quot;,&#10;                    pdfFile&#10;                )&#10;&#10;                val intent = android.content.Intent(android.content.Intent.ACTION_VIEW).apply {&#10;                    setDataAndType(uri, &quot;application/pdf&quot;)&#10;                    flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION&#10;                }&#10;&#10;                context.startActivity(intent)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;Failed to open PDF: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to open schedule PDF&quot;&#10;                )&#10;            }&#10;        } else {&#10;            Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;PDF file not found: ${pdfFile.absolutePath}&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = &quot;Schedule PDF not found&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    // Call this when user navigates to schedules screen&#10;    fun onSchedulesScreenReselected() {&#10;        val currentState = _uiState.value&#10;        if (currentState.hasUserDismissedSheet &amp;&amp;&#10;            (currentState.specialScheduleState == SpecialScheduleState.AVAILABLE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NONE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NETWORK_ERROR)) {&#10;            // Bring back the sheet in peeking state for any special schedule state, not dismissed&#10;            _uiState.value = currentState.copy(&#10;                showSpecialScheduleSheet = true,&#10;                hasUserDismissedSheet = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // Set the callback for showing toast messages&#10;    fun setShowToastCallback(callback: (String) -&gt; Unit) {&#10;        showToastCallback = callback&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.davidp799.patcotoday.ui.screens&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;enum class SpecialScheduleState {&#10;    NONE,           // No special schedules found for today&#10;    AVAILABLE,      // Special schedules are available&#10;    NETWORK_ERROR,  // Failed to check for special schedules due to network issues&#10;    LOADING         // Currently checking for special schedules&#10;}&#10;&#10;data class SchedulesUiState(&#10;    val isLoading: Boolean = true,&#10;    val arrivals: List&lt;Arrival&gt; = emptyList(),&#10;    val fromStation: String = &quot;Lindenwold&quot;,&#10;    val toStation: String = &quot;1516th &amp; Locust&quot;,&#10;    val scrollToIndex: Int = 0,&#10;    val errorMessage: String? = null,&#10;    val hasSpecialSchedule: Boolean = false,&#10;    val specialScheduleState: SpecialScheduleState = SpecialScheduleState.LOADING,&#10;    val isRefreshing: Boolean = false,&#10;    val lastRefreshTime: Long = 0L,&#10;    val isSpamming: Boolean = false,&#10;    val lastClickTime: Long = 0L,&#10;    val spamModeStartTime: Long = 0L,&#10;    val showSpecialScheduleSheet: Boolean = false,&#10;    val hasUserDismissedSheet: Boolean = false&#10;)&#10;&#10;class SchedulesScreenViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = ScheduleRepository(application)&#10;&#10;    private val _uiState = MutableStateFlow(SchedulesUiState())&#10;    val uiState: StateFlow&lt;SchedulesUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Callback for showing toast messages&#10;    private var showToastCallback: ((String) -&gt; Unit)? = null&#10;&#10;    val stationOptions = listOf(&#10;        &quot;Lindenwold&quot;,&#10;        &quot;Ashland&quot;,&#10;        &quot;Woodcrest&quot;,&#10;        &quot;Haddonfield&quot;,&#10;        &quot;Westmont&quot;,&#10;        &quot;Collingswood&quot;,&#10;        &quot;Ferry Avenue&quot;,&#10;        &quot;Broadway&quot;,&#10;        &quot;City Hall&quot;,&#10;        &quot;Franklin Square&quot;,&#10;        &quot;8th &amp; Market&quot;,&#10;        &quot;910th &amp; Locust&quot;,&#10;        &quot;1213th &amp; Locust&quot;,&#10;        &quot;1516th &amp; Locust&quot;&#10;    )&#10;&#10;    init {&#10;        // Wait for API call completion before loading schedule data&#10;        viewModelScope.launch {&#10;            try {&#10;                val mainActivity = getApplication&lt;Application&gt;() as? com.davidp799.patcotoday.MainActivity&#10;                if (mainActivity != null) {&#10;                    // Wait for the API call to complete&#10;                    mainActivity.getApiCallCompletion().await()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[SchedulesScreenViewModel]&quot;, &quot;Error waiting for API completion: ${e.message}&quot;)&#10;            }&#10;            &#10;            // Now load the schedule data (which should include any newly downloaded special schedules)&#10;            loadScheduleData()&#10;        }&#10;    }&#10;&#10;    private fun loadScheduleData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)&#10;&#10;            // Only get schedule data from local storage, no API call&#10;            val arrivals = repository.getScheduleForRoute(&#10;                fromStation = _uiState.value.fromStation,&#10;                toStation = _uiState.value.toStation&#10;            )&#10;&#10;            // Check special schedule status&#10;            val specialScheduleState = checkSpecialScheduleStatus()&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                arrivals = arrivals,&#10;                hasSpecialSchedule = specialScheduleState == SpecialScheduleState.AVAILABLE,&#10;                specialScheduleState = specialScheduleState,&#10;                showSpecialScheduleSheet = !_uiState.value.hasUserDismissedSheet,&#10;                scrollToIndex = findNextArrival(arrivals),&#10;                errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun checkSpecialScheduleStatus(): SpecialScheduleState {&#10;        return try {&#10;            val context = getApplication&lt;Application&gt;()&#10;            val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;&#10;            // Check if special schedule files exist for today&#10;            val specialDir = java.io.File(context.filesDir, &quot;schedules/special/$currentDate&quot;)&#10;            val pdfFile = java.io.File(specialDir, &quot;special_schedule.pdf&quot;)&#10;            val eastboundFile = java.io.File(specialDir, &quot;special_schedule_eastbound.csv&quot;)&#10;            val westboundFile = java.io.File(specialDir, &quot;special_schedule_westbound.csv&quot;)&#10;&#10;            val hasSpecialFiles = pdfFile.exists() || eastboundFile.exists() || westboundFile.exists()&#10;&#10;            if (hasSpecialFiles) {&#10;                SpecialScheduleState.AVAILABLE&#10;            } else {&#10;                SpecialScheduleState.NONE&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;[checkSpecialScheduleStatus]&quot;, &quot;Error checking special schedule status: ${e.message}&quot;)&#10;            SpecialScheduleState.NETWORK_ERROR&#10;        }&#10;    }&#10;&#10;    fun updateFromStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(fromStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun updateToStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(toStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun reverseStations() {&#10;        val currentFrom = _uiState.value.fromStation&#10;        val currentTo = _uiState.value.toStation&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            fromStation = currentTo,&#10;            toStation = currentFrom&#10;        )&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun refreshSchedules() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val currentState = _uiState.value&#10;&#10;        // Check if we're currently in spam mode and if enough time has passed to exit&#10;        if (currentState.isSpamming) {&#10;            val timeSinceSpamStart = currentTime - currentState.spamModeStartTime&#10;            if (timeSinceSpamStart &gt;= 5000L) {&#10;                _uiState.value = currentState.copy(&#10;                    isSpamming = false,&#10;                    lastClickTime = currentTime&#10;                )&#10;                // Continue with normal refresh logic below&#10;            } else {&#10;                _uiState.value = currentState.copy(isRefreshing = true)&#10;&#10;                // Fake loading time (1-2 seconds)&#10;                viewModelScope.launch {&#10;                    kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                    _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        val timeSinceLastClick = currentTime - currentState.lastClickTime&#10;&#10;        // Check if user is spam clicking (more than 3 clicks in 3 seconds)&#10;        val isSpamClick = timeSinceLastClick &lt; 1000L &amp;&amp; currentState.lastClickTime &gt; 0&#10;&#10;        // Update click time&#10;        _uiState.value = currentState.copy(lastClickTime = currentTime)&#10;&#10;        // If spam clicking detected, enter spam mode&#10;        if (isSpamClick &amp;&amp; !currentState.isSpamming) {&#10;            _uiState.value = _uiState.value.copy(&#10;                isSpamming = true,&#10;                spamModeStartTime = currentTime,&#10;                isRefreshing = true&#10;            )&#10;&#10;            // Fake loading time and return&#10;            viewModelScope.launch {&#10;                kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Normal refresh logic&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isRefreshing = true, errorMessage = null)&#10;&#10;            try {&#10;                // Make API call to fetch and update schedules&#10;                val result = repository.fetchAndUpdateSchedules()&#10;&#10;                result.onSuccess { apiResponse -&gt;&#10;                    // Check if schedules were actually updated&#10;                    val schedulesWereUpdated = apiResponse.regularSchedules?.updated == true&#10;&#10;                    // After API call, reload the schedule data from local storage&#10;                    val arrivals = repository.getScheduleForRoute(&#10;                        fromStation = _uiState.value.fromStation,&#10;                        toStation = _uiState.value.toStation&#10;                    )&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        arrivals = arrivals,&#10;                        scrollToIndex = findNextArrival(arrivals),&#10;                        errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null,&#10;                        lastRefreshTime = System.currentTimeMillis()&#10;                    )&#10;&#10;                    // Show appropriate toast message&#10;                    if (!schedulesWereUpdated) {&#10;                        showToastCallback?.invoke(&quot;Your schedules are up to date.&quot;)&#10;                    }&#10;                }.onFailure { error -&gt;&#10;                    Log.e(&quot;[refreshSchedules]&quot;, &quot;Manual refresh failed: ${error.message}&quot;)&#10;&#10;                    // Determine the appropriate error message based on the failure reason&#10;                    val context = getApplication&lt;Application&gt;()&#10;                    val errorMessage = when {&#10;                        // Check if failure is due to mobile data restrictions&#10;                        com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                        !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                            &quot;&quot;&#10;                        }&#10;                        // Other network-related errors&#10;                        error is java.net.UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Please check your network and try again.&quot;&#10;                        }&#10;                        error is java.net.SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;404&quot;) == true -&gt; {&#10;                            &quot;Schedule service temporarily unavailable. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;500&quot;) == true -&gt; {&#10;                            &quot;Server error occurred. Please try again later.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            &quot;Failed to update schedules. Please try again later.&quot;&#10;                        }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        errorMessage = &quot;Failed to refresh schedules: ${error.message}&quot;&#10;                    )&#10;&#10;                    // Show specific toast message&#10;                    if (errorMessage.isNotEmpty()) showToastCallback?.invoke(errorMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[refreshSchedules]&quot;, &quot;Exception during manual refresh: ${e.message}&quot;, e)&#10;&#10;                // Determine the appropriate error message for exceptions&#10;                val context = getApplication&lt;Application&gt;()&#10;                val errorMessage = when {&#10;                    // Check if exception is due to mobile data restrictions&#10;                    com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                    !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                        &quot;Download on mobile data is disabled. Enable it in settings or connect to Wi-Fi to refresh schedules.&quot;&#10;                    }&#10;                    else -&gt; {&#10;                        &quot;Failed to update schedules. Please try again later.&quot;&#10;                    }&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isRefreshing = false,&#10;                    errorMessage = &quot;Failed to refresh schedules&quot;&#10;                )&#10;&#10;                // Show specific toast message&#10;                showToastCallback?.invoke(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findNextArrival(arrivals: List&lt;Arrival&gt;): Int {&#10;        if (arrivals.isEmpty()) return 0&#10;&#10;        val currentTime = java.util.Calendar.getInstance()&#10;        val currentHour = currentTime.get(java.util.Calendar.HOUR_OF_DAY)&#10;        val currentMinute = currentTime.get(java.util.Calendar.MINUTE)&#10;        val currentTotalMinutes = currentHour * 60 + currentMinute&#10;&#10;        for (i in arrivals.indices) {&#10;            try {&#10;                val arrivalTime = arrivals[i].arrivalTime&#10;                    .replace(&quot; AM&quot;, &quot;&quot;)&#10;                    .replace(&quot; PM&quot;, &quot;&quot;)&#10;&#10;                val parts = arrivalTime.split(&quot;:&quot;)&#10;                val hour = parts[0].toInt()&#10;                val minute = parts[1].toInt()&#10;&#10;                // Convert to 24-hour format&#10;                val hour24 = if (arrivals[i].arrivalTime.contains(&quot;PM&quot;) &amp;&amp; hour != 12) {&#10;                    hour + 12&#10;                } else if (arrivals[i].arrivalTime.contains(&quot;AM&quot;) &amp;&amp; hour == 12) {&#10;                    0&#10;                } else {&#10;                    hour&#10;                }&#10;&#10;                val arrivalTotalMinutes = hour24 * 60 + minute&#10;&#10;                // Return index of first arrival that's in the future&#10;                if (arrivalTotalMinutes &gt;= currentTotalMinutes) {&#10;                    return i&#10;                }&#10;            } catch (e: Exception) {&#10;                continue&#10;            }&#10;        }&#10;&#10;        return 0 // Default to first item if no future arrivals found&#10;    }&#10;&#10;    fun dismissSpecialScheduleSheet() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSpecialScheduleSheet = false,&#10;            hasUserDismissedSheet = true&#10;        )&#10;    }&#10;&#10;    fun openSpecialSchedulePdf() {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val pdfFile = java.io.File(context.filesDir, &quot;schedules/special/$currentDate/special_schedule.pdf&quot;)&#10;&#10;        if (pdfFile.exists()) {&#10;            try {&#10;                val uri = androidx.core.content.FileProvider.getUriForFile(&#10;                    context,&#10;                    &quot;${context.packageName}.fileprovider&quot;,&#10;                    pdfFile&#10;                )&#10;&#10;                val intent = android.content.Intent(android.content.Intent.ACTION_VIEW).apply {&#10;                    setDataAndType(uri, &quot;application/pdf&quot;)&#10;                    flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION&#10;                }&#10;&#10;                context.startActivity(intent)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;Failed to open PDF: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to open schedule PDF&quot;&#10;                )&#10;            }&#10;        } else {&#10;            Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;PDF file not found: ${pdfFile.absolutePath}&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = &quot;Schedule PDF not found&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    // Call this when user navigates to schedules screen&#10;    fun onSchedulesScreenReselected() {&#10;        val currentState = _uiState.value&#10;        if (currentState.hasUserDismissedSheet &amp;&amp;&#10;            (currentState.specialScheduleState == SpecialScheduleState.AVAILABLE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NONE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NETWORK_ERROR)) {&#10;            // Bring back the sheet in peeking state for any special schedule state, not dismissed&#10;            _uiState.value = currentState.copy(&#10;                showSpecialScheduleSheet = true,&#10;                hasUserDismissedSheet = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // Set the callback for showing toast messages&#10;    fun setShowToastCallback(callback: (String) -&gt; Unit) {&#10;        showToastCallback = callback&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>