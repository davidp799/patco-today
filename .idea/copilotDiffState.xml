<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.compose.compiler)&#10;}&#10;&#10;// Load local.properties&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.davidp799.patcotoday&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.davidp799.patcotoday&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 21&#10;        versionName = &quot;2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // For development, read from local.properties if available&#10;        val apiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$apiKey\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // Use local.properties for development&#10;            val devApiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$devApiKey\&quot;&quot;)&#10;        }&#10;        release {&#10;            // Use the production API key for release builds&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2\&quot;&quot;)&#10;            isMinifyEnabled = true&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    compilerOptions {&#10;        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_1_8)&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.material.icons.extended.android)&#10;&#10;    // Add Material Compose animations for transitions&#10;    implementation(libs.androidx.animation)&#10;    implementation(libs.androidx.material)&#10;&#10;    // Add networking and API dependencies&#10;    implementation(libs.retrofit)&#10;    implementation(libs.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.logging.interceptor)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.preference.ktx)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.core.splashscreen)&#10;&#10;    // Google Play Store review dependency&#10;    implementation(libs.play.review)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.compose.compiler)&#10;}&#10;&#10;// Load local.properties&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.davidp799.patcotoday&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.davidp799.patcotoday&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 21&#10;        versionName = &quot;2.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // For development, read from local.properties if available&#10;        val apiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$apiKey\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // Use local.properties for development&#10;            val devApiKey = localProperties.getProperty(&quot;API_KEY&quot;) ?: &quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2&quot;&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;$devApiKey\&quot;&quot;)&#10;        }&#10;        release {&#10;            // Use the production API key for release builds&#10;            buildConfigField(&quot;String&quot;, &quot;API_KEY&quot;, &quot;\&quot;ZMz6Y9oU9I9nfPK2PHuR09zN4lYrFdG49it2znq2\&quot;&quot;)&#10;            isMinifyEnabled = true&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.material.icons.extended.android)&#10;&#10;    // Add Material Compose animations for transitions&#10;    implementation(libs.androidx.animation)&#10;    implementation(libs.androidx.material)&#10;&#10;    // Add networking and API dependencies&#10;    implementation(libs.retrofit)&#10;    implementation(libs.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.logging.interceptor)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.preference.ktx)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.core.splashscreen)&#10;&#10;    // Google Play Store review dependency&#10;    implementation(libs.play.review)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/ui/screens/SchedulesScreenViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/davidp799/patcotoday/ui/screens/SchedulesScreenViewModel.kt" />
              <option name="originalContent" value="package com.davidp799.patcotoday.ui.screens&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;enum class SpecialScheduleState {&#10;    NONE,           // No special schedules found for today&#10;    AVAILABLE,      // Special schedules are available&#10;    NETWORK_ERROR,  // Failed to check for special schedules due to network issues&#10;    LOADING         // Currently checking for special schedules&#10;}&#10;&#10;data class SchedulesUiState(&#10;    val isLoading: Boolean = true,&#10;    val arrivals: List&lt;Arrival&gt; = emptyList(),&#10;    val fromStation: String = &quot;Lindenwold&quot;,&#10;    val toStation: String = &quot;15–16th &amp; Locust&quot;,&#10;    val scrollToIndex: Int = 0,&#10;    val errorMessage: String? = null,&#10;    val hasSpecialSchedule: Boolean = false,&#10;    val specialScheduleState: SpecialScheduleState = SpecialScheduleState.LOADING,&#10;    val isRefreshing: Boolean = false,&#10;    val lastRefreshTime: Long = 0L,&#10;    val isSpamming: Boolean = false,&#10;    val lastClickTime: Long = 0L,&#10;    val spamModeStartTime: Long = 0L,&#10;    val showSpecialScheduleSheet: Boolean = false,&#10;    val hasUserDismissedSheet: Boolean = false&#10;)&#10;&#10;class SchedulesScreenViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = ScheduleRepository(application)&#10;&#10;    private val _uiState = MutableStateFlow(SchedulesUiState())&#10;    val uiState: StateFlow&lt;SchedulesUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Callback for showing toast messages&#10;    private var showToastCallback: ((String) -&gt; Unit)? = null&#10;&#10;    val stationOptions = listOf(&#10;        &quot;Lindenwold&quot;,&#10;        &quot;Ashland&quot;,&#10;        &quot;Woodcrest&quot;,&#10;        &quot;Haddonfield&quot;,&#10;        &quot;Westmont&quot;,&#10;        &quot;Collingswood&quot;,&#10;        &quot;Ferry Avenue&quot;,&#10;        &quot;Broadway&quot;,&#10;        &quot;City Hall&quot;,&#10;        &quot;Franklin Square&quot;,&#10;        &quot;8th &amp; Market&quot;,&#10;        &quot;9–10th &amp; Locust&quot;,&#10;        &quot;12–13th &amp; Locust&quot;,&#10;        &quot;15–16th &amp; Locust&quot;&#10;    )&#10;&#10;    init {&#10;        loadScheduleData()&#10;    }&#10;&#10;    private fun loadScheduleData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)&#10;&#10;            // Only get schedule data from local storage, no API call&#10;            val arrivals = repository.getScheduleForRoute(&#10;                fromStation = _uiState.value.fromStation,&#10;                toStation = _uiState.value.toStation&#10;            )&#10;&#10;            // Check special schedule status&#10;            val specialScheduleState = checkSpecialScheduleStatus()&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                arrivals = arrivals,&#10;                hasSpecialSchedule = specialScheduleState == SpecialScheduleState.AVAILABLE,&#10;                specialScheduleState = specialScheduleState,&#10;                showSpecialScheduleSheet = !_uiState.value.hasUserDismissedSheet,&#10;                scrollToIndex = findNextArrival(arrivals),&#10;                errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun checkSpecialScheduleStatus(): SpecialScheduleState {&#10;        return try {&#10;            val context = getApplication&lt;Application&gt;()&#10;            val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;&#10;            // Check if special schedule files exist for today&#10;            val specialDir = java.io.File(context.filesDir, &quot;schedules/special/$currentDate&quot;)&#10;            val pdfFile = java.io.File(specialDir, &quot;special_schedule.pdf&quot;)&#10;            val eastboundFile = java.io.File(specialDir, &quot;special_schedule_eastbound.csv&quot;)&#10;            val westboundFile = java.io.File(specialDir, &quot;special_schedule_westbound.csv&quot;)&#10;&#10;            val hasSpecialFiles = pdfFile.exists() || eastboundFile.exists() || westboundFile.exists()&#10;&#10;            if (hasSpecialFiles) {&#10;                SpecialScheduleState.AVAILABLE&#10;            } else {&#10;                SpecialScheduleState.NONE&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;[checkSpecialScheduleStatus]&quot;, &quot;Error checking special schedule status: ${e.message}&quot;)&#10;            SpecialScheduleState.NETWORK_ERROR&#10;        }&#10;    }&#10;&#10;    fun updateFromStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(fromStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun updateToStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(toStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun reverseStations() {&#10;        val currentFrom = _uiState.value.fromStation&#10;        val currentTo = _uiState.value.toStation&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            fromStation = currentTo,&#10;            toStation = currentFrom&#10;        )&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun refreshSchedules() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val currentState = _uiState.value&#10;&#10;        // Check if we're currently in spam mode and if enough time has passed to exit&#10;        if (currentState.isSpamming) {&#10;            val timeSinceSpamStart = currentTime - currentState.spamModeStartTime&#10;            if (timeSinceSpamStart &gt;= 5000L) {&#10;                _uiState.value = currentState.copy(&#10;                    isSpamming = false,&#10;                    lastClickTime = currentTime&#10;                )&#10;                // Continue with normal refresh logic below&#10;            } else {&#10;                _uiState.value = currentState.copy(isRefreshing = true)&#10;&#10;                // Fake loading time (1-2 seconds)&#10;                viewModelScope.launch {&#10;                    kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                    _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        val timeSinceLastClick = currentTime - currentState.lastClickTime&#10;&#10;        // Check if user is spam clicking (more than 3 clicks in 3 seconds)&#10;        val isSpamClick = timeSinceLastClick &lt; 1000L &amp;&amp; currentState.lastClickTime &gt; 0&#10;&#10;        // Update click time&#10;        _uiState.value = currentState.copy(lastClickTime = currentTime)&#10;&#10;        // If spam clicking detected, enter spam mode&#10;        if (isSpamClick &amp;&amp; !currentState.isSpamming) {&#10;            _uiState.value = _uiState.value.copy(&#10;                isSpamming = true,&#10;                spamModeStartTime = currentTime,&#10;                isRefreshing = true&#10;            )&#10;&#10;            // Fake loading time and return&#10;            viewModelScope.launch {&#10;                kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Normal refresh logic&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isRefreshing = true, errorMessage = null)&#10;&#10;            try {&#10;                // Make API call to fetch and update schedules&#10;                val result = repository.fetchAndUpdateSchedules()&#10;&#10;                result.onSuccess { apiResponse -&gt;&#10;                    // Check if schedules were actually updated&#10;                    val schedulesWereUpdated = apiResponse.regularSchedules?.updated == true&#10;&#10;                    // After API call, reload the schedule data from local storage&#10;                    val arrivals = repository.getScheduleForRoute(&#10;                        fromStation = _uiState.value.fromStation,&#10;                        toStation = _uiState.value.toStation&#10;                    )&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        arrivals = arrivals,&#10;                        scrollToIndex = findNextArrival(arrivals),&#10;                        errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null,&#10;                        lastRefreshTime = System.currentTimeMillis()&#10;                    )&#10;&#10;                    // Show appropriate toast message&#10;                    if (!schedulesWereUpdated) {&#10;                        showToastCallback?.invoke(&quot;Your schedules are up to date.&quot;)&#10;                    }&#10;                }.onFailure { error -&gt;&#10;                    Log.e(&quot;[refreshSchedules]&quot;, &quot;Manual refresh failed: ${error.message}&quot;)&#10;&#10;                    // Determine the appropriate error message based on the failure reason&#10;                    val context = getApplication&lt;Application&gt;()&#10;                    val errorMessage = when {&#10;                        // Check if failure is due to mobile data restrictions&#10;                        com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                        !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                            &quot;&quot;&#10;                        }&#10;                        // Other network-related errors&#10;                        error is java.net.UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Please check your network and try again.&quot;&#10;                        }&#10;                        error is java.net.SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;404&quot;) == true -&gt; {&#10;                            &quot;Schedule service temporarily unavailable. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;500&quot;) == true -&gt; {&#10;                            &quot;Server error occurred. Please try again later.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            &quot;Failed to update schedules. Please try again later.&quot;&#10;                        }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        errorMessage = &quot;Failed to refresh schedules: ${error.message}&quot;&#10;                    )&#10;&#10;                    // Show specific toast message&#10;                    if (errorMessage.isNotEmpty()) showToastCallback?.invoke(errorMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[refreshSchedules]&quot;, &quot;Exception during manual refresh: ${e.message}&quot;, e)&#10;&#10;                // Determine the appropriate error message for exceptions&#10;                val context = getApplication&lt;Application&gt;()&#10;                val errorMessage = when {&#10;                    // Check if exception is due to mobile data restrictions&#10;                    com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                    !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                        &quot;Download on mobile data is disabled. Enable it in settings or connect to Wi-Fi to refresh schedules.&quot;&#10;                    }&#10;                    else -&gt; {&#10;                        &quot;Failed to update schedules. Please try again later.&quot;&#10;                    }&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isRefreshing = false,&#10;                    errorMessage = &quot;Failed to refresh schedules&quot;&#10;                )&#10;&#10;                // Show specific toast message&#10;                showToastCallback?.invoke(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findNextArrival(arrivals: List&lt;Arrival&gt;): Int {&#10;        if (arrivals.isEmpty()) return 0&#10;&#10;        val currentTime = java.util.Calendar.getInstance()&#10;        val currentHour = currentTime.get(java.util.Calendar.HOUR_OF_DAY)&#10;        val currentMinute = currentTime.get(java.util.Calendar.MINUTE)&#10;        val currentTotalMinutes = currentHour * 60 + currentMinute&#10;&#10;        for (i in arrivals.indices) {&#10;            try {&#10;                val arrivalTime = arrivals[i].arrivalTime&#10;                    .replace(&quot; AM&quot;, &quot;&quot;)&#10;                    .replace(&quot; PM&quot;, &quot;&quot;)&#10;&#10;                val parts = arrivalTime.split(&quot;:&quot;)&#10;                val hour = parts[0].toInt()&#10;                val minute = parts[1].toInt()&#10;&#10;                // Convert to 24-hour format&#10;                val hour24 = if (arrivals[i].arrivalTime.contains(&quot;PM&quot;) &amp;&amp; hour != 12) {&#10;                    hour + 12&#10;                } else if (arrivals[i].arrivalTime.contains(&quot;AM&quot;) &amp;&amp; hour == 12) {&#10;                    0&#10;                } else {&#10;                    hour&#10;                }&#10;&#10;                val arrivalTotalMinutes = hour24 * 60 + minute&#10;&#10;                // Return index of first arrival that's in the future&#10;                if (arrivalTotalMinutes &gt;= currentTotalMinutes) {&#10;                    return i&#10;                }&#10;            } catch (e: Exception) {&#10;                continue&#10;            }&#10;        }&#10;&#10;        return 0 // Default to first item if no future arrivals found&#10;    }&#10;&#10;    fun dismissSpecialScheduleSheet() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSpecialScheduleSheet = false,&#10;            hasUserDismissedSheet = true&#10;        )&#10;    }&#10;&#10;    fun openSpecialSchedulePdf() {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val pdfFile = java.io.File(context.filesDir, &quot;schedules/special/$currentDate/special_schedule.pdf&quot;)&#10;&#10;        if (pdfFile.exists()) {&#10;            try {&#10;                val uri = androidx.core.content.FileProvider.getUriForFile(&#10;                    context,&#10;                    &quot;${context.packageName}.fileprovider&quot;,&#10;                    pdfFile&#10;                )&#10;&#10;                val intent = android.content.Intent(android.content.Intent.ACTION_VIEW).apply {&#10;                    setDataAndType(uri, &quot;application/pdf&quot;)&#10;                    flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION&#10;                }&#10;&#10;                context.startActivity(intent)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;Failed to open PDF: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to open schedule PDF&quot;&#10;                )&#10;            }&#10;        } else {&#10;            Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;PDF file not found: ${pdfFile.absolutePath}&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = &quot;Schedule PDF not found&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    // Call this when user navigates to schedules screen&#10;    fun onSchedulesScreenReselected() {&#10;        val currentState = _uiState.value&#10;        if (currentState.hasUserDismissedSheet &amp;&amp;&#10;            (currentState.specialScheduleState == SpecialScheduleState.AVAILABLE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NONE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NETWORK_ERROR)) {&#10;            // Bring back the sheet in peeking state for any special schedule state, not dismissed&#10;            _uiState.value = currentState.copy(&#10;                showSpecialScheduleSheet = true,&#10;                hasUserDismissedSheet = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // Set the callback for showing toast messages&#10;    fun setShowToastCallback(callback: (String) -&gt; Unit) {&#10;        showToastCallback = callback&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.davidp799.patcotoday.ui.screens&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.davidp799.patcotoday.data.repository.ScheduleRepository&#10;import com.davidp799.patcotoday.utils.Arrival&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;enum class SpecialScheduleState {&#10;    NONE,           // No special schedules found for today&#10;    AVAILABLE,      // Special schedules are available&#10;    NETWORK_ERROR,  // Failed to check for special schedules due to network issues&#10;    LOADING         // Currently checking for special schedules&#10;}&#10;&#10;data class SchedulesUiState(&#10;    val isLoading: Boolean = true,&#10;    val arrivals: List&lt;Arrival&gt; = emptyList(),&#10;    val fromStation: String = &quot;Lindenwold&quot;,&#10;    val toStation: String = &quot;15–16th &amp; Locust&quot;,&#10;    val scrollToIndex: Int = 0,&#10;    val errorMessage: String? = null,&#10;    val hasSpecialSchedule: Boolean = false,&#10;    val specialScheduleState: SpecialScheduleState = SpecialScheduleState.LOADING,&#10;    val isRefreshing: Boolean = false,&#10;    val lastRefreshTime: Long = 0L,&#10;    val isSpamming: Boolean = false,&#10;    val lastClickTime: Long = 0L,&#10;    val spamModeStartTime: Long = 0L,&#10;    val showSpecialScheduleSheet: Boolean = false,&#10;    val hasUserDismissedSheet: Boolean = false&#10;)&#10;&#10;class SchedulesScreenViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val repository = ScheduleRepository(application)&#10;&#10;    private val _uiState = MutableStateFlow(SchedulesUiState())&#10;    val uiState: StateFlow&lt;SchedulesUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Callback for showing toast messages&#10;    private var showToastCallback: ((String) -&gt; Unit)? = null&#10;&#10;    val stationOptions = listOf(&#10;        &quot;Lindenwold&quot;,&#10;        &quot;Ashland&quot;,&#10;        &quot;Woodcrest&quot;,&#10;        &quot;Haddonfield&quot;,&#10;        &quot;Westmont&quot;,&#10;        &quot;Collingswood&quot;,&#10;        &quot;Ferry Avenue&quot;,&#10;        &quot;Broadway&quot;,&#10;        &quot;City Hall&quot;,&#10;        &quot;Franklin Square&quot;,&#10;        &quot;8th &amp; Market&quot;,&#10;        &quot;9–10th &amp; Locust&quot;,&#10;        &quot;12–13th &amp; Locust&quot;,&#10;        &quot;15–16th &amp; Locust&quot;&#10;    )&#10;&#10;    init {&#10;        // Wait for API call completion before loading schedule data&#10;        viewModelScope.launch {&#10;            try {&#10;                val mainActivity = getApplication&lt;Application&gt;() as? com.davidp799.patcotoday.MainActivity&#10;                if (mainActivity != null) {&#10;                    // Wait for the API call to complete&#10;                    mainActivity.getApiCallCompletion().await()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[SchedulesScreenViewModel]&quot;, &quot;Error waiting for API completion: ${e.message}&quot;)&#10;            }&#10;            &#10;            // Now load the schedule data (which should include any newly downloaded special schedules)&#10;            loadScheduleData()&#10;        }&#10;    }&#10;&#10;    private fun loadScheduleData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, errorMessage = null)&#10;&#10;            // Only get schedule data from local storage, no API call&#10;            val arrivals = repository.getScheduleForRoute(&#10;                fromStation = _uiState.value.fromStation,&#10;                toStation = _uiState.value.toStation&#10;            )&#10;&#10;            // Check special schedule status&#10;            val specialScheduleState = checkSpecialScheduleStatus()&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                arrivals = arrivals,&#10;                hasSpecialSchedule = specialScheduleState == SpecialScheduleState.AVAILABLE,&#10;                specialScheduleState = specialScheduleState,&#10;                showSpecialScheduleSheet = !_uiState.value.hasUserDismissedSheet,&#10;                scrollToIndex = findNextArrival(arrivals),&#10;                errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun checkSpecialScheduleStatus(): SpecialScheduleState {&#10;        return try {&#10;            val context = getApplication&lt;Application&gt;()&#10;            val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;&#10;            // Check if special schedule files exist for today&#10;            val specialDir = java.io.File(context.filesDir, &quot;schedules/special/$currentDate&quot;)&#10;            val pdfFile = java.io.File(specialDir, &quot;special_schedule.pdf&quot;)&#10;            val eastboundFile = java.io.File(specialDir, &quot;special_schedule_eastbound.csv&quot;)&#10;            val westboundFile = java.io.File(specialDir, &quot;special_schedule_westbound.csv&quot;)&#10;&#10;            val hasSpecialFiles = pdfFile.exists() || eastboundFile.exists() || westboundFile.exists()&#10;&#10;            if (hasSpecialFiles) {&#10;                SpecialScheduleState.AVAILABLE&#10;            } else {&#10;                SpecialScheduleState.NONE&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;[checkSpecialScheduleStatus]&quot;, &quot;Error checking special schedule status: ${e.message}&quot;)&#10;            SpecialScheduleState.NETWORK_ERROR&#10;        }&#10;    }&#10;&#10;    fun updateFromStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(fromStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun updateToStation(station: String) {&#10;        _uiState.value = _uiState.value.copy(toStation = station)&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun reverseStations() {&#10;        val currentFrom = _uiState.value.fromStation&#10;        val currentTo = _uiState.value.toStation&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            fromStation = currentTo,&#10;            toStation = currentFrom&#10;        )&#10;        // Reload schedule data when stations change&#10;        loadScheduleData()&#10;    }&#10;&#10;    fun refreshSchedules() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val currentState = _uiState.value&#10;&#10;        // Check if we're currently in spam mode and if enough time has passed to exit&#10;        if (currentState.isSpamming) {&#10;            val timeSinceSpamStart = currentTime - currentState.spamModeStartTime&#10;            if (timeSinceSpamStart &gt;= 5000L) {&#10;                _uiState.value = currentState.copy(&#10;                    isSpamming = false,&#10;                    lastClickTime = currentTime&#10;                )&#10;                // Continue with normal refresh logic below&#10;            } else {&#10;                _uiState.value = currentState.copy(isRefreshing = true)&#10;&#10;                // Fake loading time (1-2 seconds)&#10;                viewModelScope.launch {&#10;                    kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                    _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        val timeSinceLastClick = currentTime - currentState.lastClickTime&#10;&#10;        // Check if user is spam clicking (more than 3 clicks in 3 seconds)&#10;        val isSpamClick = timeSinceLastClick &lt; 1000L &amp;&amp; currentState.lastClickTime &gt; 0&#10;&#10;        // Update click time&#10;        _uiState.value = currentState.copy(lastClickTime = currentTime)&#10;&#10;        // If spam clicking detected, enter spam mode&#10;        if (isSpamClick &amp;&amp; !currentState.isSpamming) {&#10;            _uiState.value = _uiState.value.copy(&#10;                isSpamming = true,&#10;                spamModeStartTime = currentTime,&#10;                isRefreshing = true&#10;            )&#10;&#10;            // Fake loading time and return&#10;            viewModelScope.launch {&#10;                kotlinx.coroutines.delay((1000..2000).random().toLong())&#10;                _uiState.value = _uiState.value.copy(isRefreshing = false)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Normal refresh logic&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isRefreshing = true, errorMessage = null)&#10;&#10;            try {&#10;                // Make API call to fetch and update schedules&#10;                val result = repository.fetchAndUpdateSchedules()&#10;&#10;                result.onSuccess { apiResponse -&gt;&#10;                    // Check if schedules were actually updated&#10;                    val schedulesWereUpdated = apiResponse.regularSchedules?.updated == true&#10;&#10;                    // After API call, reload the schedule data from local storage&#10;                    val arrivals = repository.getScheduleForRoute(&#10;                        fromStation = _uiState.value.fromStation,&#10;                        toStation = _uiState.value.toStation&#10;                    )&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        arrivals = arrivals,&#10;                        scrollToIndex = findNextArrival(arrivals),&#10;                        errorMessage = if (arrivals.isEmpty()) &quot;No schedule data available&quot; else null,&#10;                        lastRefreshTime = System.currentTimeMillis()&#10;                    )&#10;&#10;                    // Show appropriate toast message&#10;                    if (!schedulesWereUpdated) {&#10;                        showToastCallback?.invoke(&quot;Your schedules are up to date.&quot;)&#10;                    }&#10;                }.onFailure { error -&gt;&#10;                    Log.e(&quot;[refreshSchedules]&quot;, &quot;Manual refresh failed: ${error.message}&quot;)&#10;&#10;                    // Determine the appropriate error message based on the failure reason&#10;                    val context = getApplication&lt;Application&gt;()&#10;                    val errorMessage = when {&#10;                        // Check if failure is due to mobile data restrictions&#10;                        com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                        !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                            &quot;&quot;&#10;                        }&#10;                        // Other network-related errors&#10;                        error is java.net.UnknownHostException -&gt; {&#10;                            &quot;No internet connection. Please check your network and try again.&quot;&#10;                        }&#10;                        error is java.net.SocketTimeoutException -&gt; {&#10;                            &quot;Request timed out. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;404&quot;) == true -&gt; {&#10;                            &quot;Schedule service temporarily unavailable. Please try again later.&quot;&#10;                        }&#10;                        error.message?.contains(&quot;500&quot;) == true -&gt; {&#10;                            &quot;Server error occurred. Please try again later.&quot;&#10;                        }&#10;                        else -&gt; {&#10;                            &quot;Failed to update schedules. Please try again later.&quot;&#10;                        }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isRefreshing = false,&#10;                        errorMessage = &quot;Failed to refresh schedules: ${error.message}&quot;&#10;                    )&#10;&#10;                    // Show specific toast message&#10;                    if (errorMessage.isNotEmpty()) showToastCallback?.invoke(errorMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[refreshSchedules]&quot;, &quot;Exception during manual refresh: ${e.message}&quot;, e)&#10;&#10;                // Determine the appropriate error message for exceptions&#10;                val context = getApplication&lt;Application&gt;()&#10;                val errorMessage = when {&#10;                    // Check if exception is due to mobile data restrictions&#10;                    com.davidp799.patcotoday.utils.NetworkUtils.isOnMobileData(context) &amp;&amp;&#10;                    !com.davidp799.patcotoday.utils.NetworkUtils.isDownloadOnMobileDataEnabled(context) -&gt; {&#10;                        &quot;Download on mobile data is disabled. Enable it in settings or connect to Wi-Fi to refresh schedules.&quot;&#10;                    }&#10;                    else -&gt; {&#10;                        &quot;Failed to update schedules. Please try again later.&quot;&#10;                    }&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isRefreshing = false,&#10;                    errorMessage = &quot;Failed to refresh schedules&quot;&#10;                )&#10;&#10;                // Show specific toast message&#10;                showToastCallback?.invoke(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findNextArrival(arrivals: List&lt;Arrival&gt;): Int {&#10;        if (arrivals.isEmpty()) return 0&#10;&#10;        val currentTime = java.util.Calendar.getInstance()&#10;        val currentHour = currentTime.get(java.util.Calendar.HOUR_OF_DAY)&#10;        val currentMinute = currentTime.get(java.util.Calendar.MINUTE)&#10;        val currentTotalMinutes = currentHour * 60 + currentMinute&#10;&#10;        for (i in arrivals.indices) {&#10;            try {&#10;                val arrivalTime = arrivals[i].arrivalTime&#10;                    .replace(&quot; AM&quot;, &quot;&quot;)&#10;                    .replace(&quot; PM&quot;, &quot;&quot;)&#10;&#10;                val parts = arrivalTime.split(&quot;:&quot;)&#10;                val hour = parts[0].toInt()&#10;                val minute = parts[1].toInt()&#10;&#10;                // Convert to 24-hour format&#10;                val hour24 = if (arrivals[i].arrivalTime.contains(&quot;PM&quot;) &amp;&amp; hour != 12) {&#10;                    hour + 12&#10;                } else if (arrivals[i].arrivalTime.contains(&quot;AM&quot;) &amp;&amp; hour == 12) {&#10;                    0&#10;                } else {&#10;                    hour&#10;                }&#10;&#10;                val arrivalTotalMinutes = hour24 * 60 + minute&#10;&#10;                // Return index of first arrival that's in the future&#10;                if (arrivalTotalMinutes &gt;= currentTotalMinutes) {&#10;                    return i&#10;                }&#10;            } catch (e: Exception) {&#10;                continue&#10;            }&#10;        }&#10;&#10;        return 0 // Default to first item if no future arrivals found&#10;    }&#10;&#10;    fun dismissSpecialScheduleSheet() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSpecialScheduleSheet = false,&#10;            hasUserDismissedSheet = true&#10;        )&#10;    }&#10;&#10;    fun openSpecialSchedulePdf() {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val currentDate = java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val pdfFile = java.io.File(context.filesDir, &quot;schedules/special/$currentDate/special_schedule.pdf&quot;)&#10;&#10;        if (pdfFile.exists()) {&#10;            try {&#10;                val uri = androidx.core.content.FileProvider.getUriForFile(&#10;                    context,&#10;                    &quot;${context.packageName}.fileprovider&quot;,&#10;                    pdfFile&#10;                )&#10;&#10;                val intent = android.content.Intent(android.content.Intent.ACTION_VIEW).apply {&#10;                    setDataAndType(uri, &quot;application/pdf&quot;)&#10;                    flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION&#10;                }&#10;&#10;                context.startActivity(intent)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;Failed to open PDF: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to open schedule PDF&quot;&#10;                )&#10;            }&#10;        } else {&#10;            Log.e(&quot;[openSpecialSchedulePdf]&quot;, &quot;PDF file not found: ${pdfFile.absolutePath}&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = &quot;Schedule PDF not found&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    // Call this when user navigates to schedules screen&#10;    fun onSchedulesScreenReselected() {&#10;        val currentState = _uiState.value&#10;        if (currentState.hasUserDismissedSheet &amp;&amp;&#10;            (currentState.specialScheduleState == SpecialScheduleState.AVAILABLE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NONE ||&#10;             currentState.specialScheduleState == SpecialScheduleState.NETWORK_ERROR)) {&#10;            // Bring back the sheet in peeking state for any special schedule state, not dismissed&#10;            _uiState.value = currentState.copy(&#10;                showSpecialScheduleSheet = true,&#10;                hasUserDismissedSheet = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // Set the callback for showing toast messages&#10;    fun setShowToastCallback(callback: (String) -&gt; Unit) {&#10;        showToastCallback = callback&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>